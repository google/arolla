{# jinja2 file itself is NOT auto generated. -#}
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: {{ build_target }}
{% for hdr in hdrs %}
#include "{{ hdr }}"
{%- endfor %}{# hdr #}
#include "arolla/qexpr/eval_context.h"
#include "arolla/qexpr/generated_operator.h"
#include "arolla/qexpr/lifting.h"
#include "arolla/qexpr/operators.h"
#include "arolla/qexpr/result_type_traits.h"
#include "arolla/qtype/base_types.h"
#include "arolla/util/operator_name.h"
#include "arolla/util/init_arolla.h"
#include "arolla/util/types.h"

namespace {

using ::arolla::qexpr_impl::ResultTypeTraits;
using ::arolla::TypedSlot;

template<typename OpFunctor, typename... Args>
inline ABSL_ATTRIBUTE_ALWAYS_INLINE constexpr auto
WrapToTakeEvaluationContext() {
  return [](::arolla::EvaluationContext* ctx, const Args&... args)
        ABSL_ATTRIBUTE_ALWAYS_INLINE {
        if constexpr (std::is_invocable_v<OpFunctor, Args...>) {
          // Suppress compiler complaints about unused variables.
          ((void)(ctx));
          static_assert(
              std::is_invocable_v<const OpFunctor&, Args...>,
              "operator() must be const");
          return OpFunctor()(args...);
        } else {
          static_assert(
              std::is_invocable_v<
                  OpFunctor, ::arolla::EvaluationContext*, Args...>,
              "operator() is not defined for the given type combination. "
              "Both `::arolla::EvaluationContext*, Args...` and `Args..` "
              "are not available.");
          static_assert(
              std::is_invocable_v<
                  const OpFunctor&, ::arolla::EvaluationContext*, Args...>,
              "operator() must be const");
          return OpFunctor()(ctx, args...);
        }
      };
}

}  // namespace

{%- set op_name_as_cpp_identifier = op_name | replace(".", " ") | replace("_", " ") | title | replace(" ", "") %}

{%- for op in overloads %}
{%-   set op_id = loop.index %}
{%-   set bound_op_class = "{}_Impl{}".format(op_name_as_cpp_identifier, op_id) %}

namespace {

using OpFunctor{{ op_id }} = {{ op.op_class }};

constexpr auto kOpFunctorWithContext{{ op_id }} =
    WrapToTakeEvaluationContext<OpFunctor{{ op_id }}
{%-     for arg in op.args -%}
          , ::arolla::DecayDoNotLiftTag<{{arg}}>
{%-     endfor -%}
    >();

using ResultTraits{{ op_id }} = ResultTypeTraits<
    typename ::arolla::meta::function_traits<
        decltype(kOpFunctorWithContext{{ op_id }})>::return_type>;
using OutputSlots{{ op_id }} = ResultTraits{{ op_id }}::Slots;

struct InputSlots{{ op_id }} {
{%-     for arg_type in op.args %}
  ::arolla::FrameLayout::Slot<::arolla::DecayDoNotLiftTag<{{ arg_type }}>> slot_{{ loop.index0 }};
{%-     endfor %}{# arg_type #}
};

class {{ bound_op_class }} final : public ::arolla::BoundOperator {
 public:
  {{ bound_op_class }}(InputSlots{{ op_id }} input_slots, OutputSlots{{ op_id }} output_slots)
      : input_slots_(std::move(input_slots)),
        output_slots_(std::move(output_slots)) {}

  void Run(::arolla::EvaluationContext* ctx,
           ::arolla::FramePtr frame) const final {
    ResultTraits{{ op_id }}::SaveAndReturn(ctx, frame, output_slots_,
        kOpFunctorWithContext{{ op_id }}(ctx
{%-     for arg in op.args -%}
                              ,
                              frame.Get(input_slots_.slot_{{ loop.index0 }})
{%-     endfor -%}
    ));
  }

 private:
  const InputSlots{{ op_id }} input_slots_;
  const OutputSlots{{ op_id }} output_slots_;
};

} // namespace

extern "C" {

static std::unique_ptr<::arolla::BoundOperator>
MakeBoundOp{{ op_id }}(absl::Span<const TypedSlot> input_slots, TypedSlot output_slot) {
  InputSlots{{ op_id }} inputs = {
{%-     for arg_type in op.args %}
      input_slots[{{ loop.index0 }}].UnsafeToSlot<::arolla::DecayDoNotLiftTag<{{ arg_type }}>>()
      {{- "," if not loop.last else "" }}
{%-     endfor %}{# arg_type -#}
  };
  auto outputs = ResultTraits{{ op_id }}::UnsafeToSlots({output_slot});
  // By explicit creation of unique_ptr to the base class we avoid
  // instantiation of std::unique_ptr<{{ bound_op_class }}>.
  return std::unique_ptr<::arolla::BoundOperator>(
      new {{ bound_op_class }}(inputs, outputs));
}

}  // extern "C"

{%- endfor %}{# op #}

AROLLA_INITIALIZER(
    .reverse_deps = {::arolla::initializer_dep::kOperators,
                     ::arolla::initializer_dep::kQExprOperators},
    .init_fn = [] {
        return ::arolla::qexpr_impl::RegisterGeneratedOperators(
            AROLLA_OPERATOR_NAME("{{ op_name }}"),
            {
{%- for op in overloads %}
{%-   set op_id = loop.index %}
              ::arolla::QExprOperatorSignature::Get({
{%-     for arg_type in op.args %}
                  ::arolla::GetQType<::arolla::DecayDoNotLiftTag<{{ arg_type }}>>()
                  {{- "," if not loop.last else "" }}
{%-     endfor %}{# arg_type -#}
                  },
                  ResultTraits{{ op_id }}::GetOutputType()),
{%- endfor %}{# op #}
            },
            {
{%- for op in overloads %}
{%-   set op_id = loop.index %}
              &::MakeBoundOp{{ op_id }},
{%- endfor %}{# op #}
            },
            /*is_individual_operator=*/{{"true" if is_individual_operator else "false"}}
            );
    })

{# force keeping trailing newline #}
