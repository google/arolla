// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_repeated_proto_input_loader_with_parent_intermediate_node_collected


#include "arolla/codegen/io/multi_loader.h"
#include "arolla/dense_array/dense_array.h"
#include "arolla/dense_array/qtype/types.h"
#include "arolla/proto/test.pb.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/util/map.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::InputLoaderPtr;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetRepeatedProtoLoaderWithParentIntermediateNodeCollectionImplNamespace {

using Input = ::testing_namespace::Root;

namespace {
namespace {

namespace multi_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;
using ::arolla::codegen::io::NamedTypesBuilder;

// In this namespace protopath inputs with `DenseArray` are being loaded.

using HierarchicalMultiValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalMultiValueRequestedInputsData<
        /*kLeafCount=*/6,
        /*kNodeCount=*/12>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalMultiValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:

  // protopath=`inners[:]/root_reference/inner/a` name=`inners/rr/inner/a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).root_reference().inner().a())>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[0],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/root_reference/inner/as[0]` name=`inners/rr/inner/a0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).root_reference().inner().as(0))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[1],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/root_reference/inners[0]/a` name=`inners/rr/inners0/a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).root_reference().inners(0).a())>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[2],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/root_reference/inners[0]/as[0]` name=`inners/rr/inners0/a0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).root_reference().inners(0).as(0))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[3],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/root_reference/inners[1]/a` name=`inners/rr/inners1/a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable4(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).root_reference().inners(1).a())>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[4],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

  // protopath=`inners[:]/root_reference/inners[1]/as[0]` name=`inners/rr/inners1/a0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable5(size_t offset) const {
    using value_type = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).root_reference().inners(1).as(0))>;
    using result_type = HierarchicalMultiValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(
        requested_inputs->common.leaf_frame_offsets[5],
        kSkippedOffset);
    return frame.GetMutable(
      ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(
          offset));
  }

};


using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable4(0))>>;
using ResultType_5 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable5(0))>>;

// Traverse the proto and put results for all DenaseArray values to the frame.
class SlotSetter {
 public:
  // Collects all intermediate results and sizes we need for further individual
  // DenseArray creation.
  // Fills `single_` and `intermediate*_`.
  void CollectIntermediateResults(
     const Input& input,
     const HierarchicalMultiValueRequestedInputs& requested_inputs) {
   const Input& tmp_5 = input;

    // protopath=`inners[:]`
    if (requested_inputs.common.node_requested[3]) {
      multi_.intermediate3.reserve(tmp_5.inners().size());
    }

    for (const auto& tmp_4 : tmp_5.inners()) {
      if (requested_inputs.common.node_requested[3]) {
        multi_.intermediate3.push_back(nullptr);
      }
      // protopath=`inners[:]/root_reference`
      [&]() {
        if (!requested_inputs.common.node_requested[3]) {
          return;
        }
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_4, root_reference))) {
          return;
        }
        const auto& tmp_3 = tmp_4.root_reference();
        multi_.intermediate3.back() = &tmp_3;
      }();
    }
  }
  // Returns total size of the array for
  // protopath=`inners[:]/root_reference/inner/a` name=`inners/rr/inner/a`
  size_t TotalSize0() const {
    return multi_.intermediate3.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/root_reference/inner/a` name=`inners/rr/inner/a`
  void CollectResultFromIntermediate0(
      ResultType_0* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize0();
    using ValueT = ResultType_0::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]/root_reference`
    for (const auto* intermediate_ptr : multi_.intermediate3) {
      if (intermediate_ptr == nullptr) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_9 = *intermediate_ptr;
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_9, inner))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_2 = tmp_9.inner();

      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, a))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_0 = tmp_2.a();
      id++;
      inserter.Add(tmp_0);
    }

    *output = ResultType_0{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/root_reference/inner/as[0]` name=`inners/rr/inner/a0`
  size_t TotalSize1() const {
    return multi_.intermediate3.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/root_reference/inner/as[0]` name=`inners/rr/inner/a0`
  void CollectResultFromIntermediate1(
      ResultType_1* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize1();
    using ValueT = ResultType_1::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]/root_reference`
    for (const auto* intermediate_ptr : multi_.intermediate3) {
      if (intermediate_ptr == nullptr) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_9 = *intermediate_ptr;
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_9, inner))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_2 = tmp_9.inner();

      if (!(tmp_2.as().size() > 0)) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_1 = tmp_2.as(0);
      id++;
      inserter.Add(tmp_1);
    }

    *output = ResultType_1{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/root_reference/inners[0]/a` name=`inners/rr/inners0/a`
  size_t TotalSize2() const {
    return multi_.intermediate3.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/root_reference/inners[0]/a` name=`inners/rr/inners0/a`
  void CollectResultFromIntermediate2(
      ResultType_2* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize2();
    using ValueT = ResultType_2::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]/root_reference`
    for (const auto* intermediate_ptr : multi_.intermediate3) {
      if (intermediate_ptr == nullptr) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_9 = *intermediate_ptr;
      if (!(tmp_9.inners().size() > 0)) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_5 = tmp_9.inners(0);

      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_5, a))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_3 = tmp_5.a();
      id++;
      inserter.Add(tmp_3);
    }

    *output = ResultType_2{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/root_reference/inners[0]/as[0]` name=`inners/rr/inners0/a0`
  size_t TotalSize3() const {
    return multi_.intermediate3.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/root_reference/inners[0]/as[0]` name=`inners/rr/inners0/a0`
  void CollectResultFromIntermediate3(
      ResultType_3* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize3();
    using ValueT = ResultType_3::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]/root_reference`
    for (const auto* intermediate_ptr : multi_.intermediate3) {
      if (intermediate_ptr == nullptr) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_9 = *intermediate_ptr;
      if (!(tmp_9.inners().size() > 0)) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_5 = tmp_9.inners(0);

      if (!(tmp_5.as().size() > 0)) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_4 = tmp_5.as(0);
      id++;
      inserter.Add(tmp_4);
    }

    *output = ResultType_3{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/root_reference/inners[1]/a` name=`inners/rr/inners1/a`
  size_t TotalSize4() const {
    return multi_.intermediate3.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/root_reference/inners[1]/a` name=`inners/rr/inners1/a`
  void CollectResultFromIntermediate4(
      ResultType_4* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize4();
    using ValueT = ResultType_4::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]/root_reference`
    for (const auto* intermediate_ptr : multi_.intermediate3) {
      if (intermediate_ptr == nullptr) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_9 = *intermediate_ptr;
      if (!(tmp_9.inners().size() > 1)) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_8 = tmp_9.inners(1);

      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_8, a))) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_6 = tmp_8.a();
      id++;
      inserter.Add(tmp_6);
    }

    *output = ResultType_4{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }

  // Returns total size of the array for
  // protopath=`inners[:]/root_reference/inners[1]/as[0]` name=`inners/rr/inners1/a0`
  size_t TotalSize5() const {
    return multi_.intermediate3.size();
  }

  // Start from one of the collected intermediate nodes and create DenseArray
  // in the slot for
  // protopath=`inners[:]/root_reference/inners[1]/as[0]` name=`inners/rr/inners1/a0`
  void CollectResultFromIntermediate5(
      ResultType_5* output, RawBufferFactory* buffer_factory) const {
    size_t total_size = TotalSize5();
    using ValueT = ResultType_5::base_type;
    typename ::arolla::Buffer<ValueT>::Builder bldr(total_size, buffer_factory);
    auto inserter = bldr.GetInserter();
    int64_t id = 0;
    ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, buffer_factory);
    // protopath=`inners[:]/root_reference`
    for (const auto* intermediate_ptr : multi_.intermediate3) {
      if (intermediate_ptr == nullptr) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_9 = *intermediate_ptr;
      if (!(tmp_9.inners().size() > 1)) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_8 = tmp_9.inners(1);

      if (!(tmp_8.as().size() > 0)) {
        bitmap_bldr.AddMissed(id++); inserter.SkipN(1);
        continue;
      }
      const auto& tmp_7 = tmp_8.as(0);
      id++;
      inserter.Add(tmp_7);
    }

    *output = ResultType_5{
        std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
  }



 void CollectResults(
     const Input& input, const OutputProvider& outputs,
     RawBufferFactory* buffer_factory) {
   single_.intermediate5 = &input;
   CollectIntermediateResults(input, *outputs.requested_inputs);

    // protopath=`inners[:]`
    // protopath=`inners[:]/root_reference`
    // protopath=`inners[:]/root_reference/inner`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[0]) {
        return;
      }
      // protopath=`inners[:]/root_reference/inner/a` name=`inners/rr/inner/a`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[0];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate0(
            outputs.GetMutable0(offset), buffer_factory);
      }
      // protopath=`inners[:]/root_reference/inner/as[0]` name=`inners/rr/inner/a0`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[1];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate1(
            outputs.GetMutable1(offset), buffer_factory);
      }
    }();
    // protopath=`inners[:]/root_reference/inners[0]`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[1]) {
        return;
      }
      // protopath=`inners[:]/root_reference/inners[0]/a` name=`inners/rr/inners0/a`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[2];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate2(
            outputs.GetMutable2(offset), buffer_factory);
      }
      // protopath=`inners[:]/root_reference/inners[0]/as[0]` name=`inners/rr/inners0/a0`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[3];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate3(
            outputs.GetMutable3(offset), buffer_factory);
      }
    }();
    // protopath=`inners[:]/root_reference/inners[1]`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[2]) {
        return;
      }
      // protopath=`inners[:]/root_reference/inners[1]/a` name=`inners/rr/inners1/a`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[4];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate4(
            outputs.GetMutable4(offset), buffer_factory);
      }
      // protopath=`inners[:]/root_reference/inners[1]/as[0]` name=`inners/rr/inners1/a0`
      if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[5];
          offset != kSkippedOffset) {
        CollectResultFromIntermediate5(
            outputs.GetMutable5(offset), buffer_factory);
      }
    }();
 }

 private:
  // Intermediate non vector data: pointers to messages and sizes.
  struct SingleValueData {
    const Input* intermediate5 = nullptr;
  };

  // Intermediate vector data: collection of pointers to messages.
  struct MultiValueData {
    using MsgType3 = std::decay_t<decltype(
        std::declval<const Input&>().inners(0).root_reference())>;
    std::vector<const MsgType3*> intermediate3;
  };

  SingleValueData single_;
  MultiValueData multi_;
};

// InputLoader for all DenseArray value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
    : StaticInputLoader<Input>(
      // use special builder to reduce binary size and stack pressure
          []() {
            NamedTypesBuilder builder;
            builder.Add(
                R"RL_CODEGEN_DELIM(inners/rr/inner/a)RL_CODEGEN_DELIM",
                ::arolla::GetQType<ResultType_0>());
            builder.Add(
                R"RL_CODEGEN_DELIM(inners/rr/inner/a0)RL_CODEGEN_DELIM",
                ::arolla::GetQType<ResultType_1>());
            builder.Add(
                R"RL_CODEGEN_DELIM(inners/rr/inners0/a)RL_CODEGEN_DELIM",
                ::arolla::GetQType<ResultType_2>());
            builder.Add(
                R"RL_CODEGEN_DELIM(inners/rr/inners0/a0)RL_CODEGEN_DELIM",
                ::arolla::GetQType<ResultType_3>());
            builder.Add(
                R"RL_CODEGEN_DELIM(inners/rr/inners1/a)RL_CODEGEN_DELIM",
                ::arolla::GetQType<ResultType_4>());
            builder.Add(
                R"RL_CODEGEN_DELIM(inners/rr/inners1/a0)RL_CODEGEN_DELIM",
                ::arolla::GetQType<ResultType_5>());
            return std::move(builder).Build();
          }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalMultiValueRequestedInputs>();
    auto tree = []() {
      std::vector<std::vector<size_t>> tree(12);
      tree[2] = {0,1};
      tree[5] = {3,4};
      tree[8] = {6,7};
      tree[9] = {2,5,8};
      tree[10] = {9};
      tree[11] = {10};
      return tree;
    }();
    CreateHierarchicalMultiValueRequestedInputs(
      optional_slots,
      tree,
      inputs.get());
    return BoundInputLoader<Input>([inputs=std::move(*inputs)](
        const Input& input, FramePtr frame, RawBufferFactory* buffer_factory) {
      OutputProvider output_getter{&inputs, frame};
      SlotSetter slot_setter;
      slot_setter.CollectResults(input, output_getter, buffer_factory);
      return OkStatus();
    });
  }
};

}  // namespace multi_value_protopath
}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>*
GetCollectionInputLoader() {
  static const InputLoader<Input>* impl = ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<InputLoader<Input>*>(
            new multi_value_protopath::Loader()))
      )->release();
  return impl;
}
}  // namespace


namespace {

constexpr auto GetAllShardsInputLoader =
    ::my_namespace_GetRepeatedProtoLoaderWithParentIntermediateNodeCollectionImplNamespace::GetCollectionInputLoader;

}  // namespace
}  // namespace my_namespace_GetRepeatedProtoLoaderWithParentIntermediateNodeCollectionImplNamespace

namespace my_namespace {

::arolla::InputLoaderPtr<::testing_namespace::Root>
GetRepeatedProtoLoaderWithParentIntermediateNodeCollection() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetRepeatedProtoLoaderWithParentIntermediateNodeCollectionImplNamespace::GetAllShardsInputLoader());
}

}  // namespace my_namespace

