// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_input_loader_set

#include <memory>

#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace aaa_GetLoader1ImplNamespace {

using Input = ::std::array<int, 10>;

namespace {
namespace {
// Special value to mark not requested slot.
constexpr size_t kSkippedOffset = std::numeric_limits<size_t>::max();

constexpr auto accessor_lambda_0 = [](const auto& input) { return input[3]; };
using AccessorResultType_0 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_0), Input>;

constexpr auto accessor_lambda_1 = [](const auto& input) { return input[5]; };
using AccessorResultType_1 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_1), Input>;

// Calling all accessors and put results to the frame.
struct AccessorsSlotSetter {
  // kSkippedOffset means a skipped slot
  size_t offsets[2];
  // true iff at least one slot in the group of size 8 is present
  bool offset_group_present[1] = {false};

  Status operator()(const Input& input, FramePtr frame,
                    RawBufferFactory* factory) const {
    if (offset_group_present[0]) {
      if (size_t offset = offsets[0]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_0, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_0>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[1]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_1, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_1>::UnsafeSlotFromOffset(offset)));
      }
    }
    return OkStatus();
  }
};

// InputLoader based on accessors.
class AccessorsLoader final : public ::arolla::StaticInputLoader<Input> {
 public:
  AccessorsLoader()
      : ::arolla::StaticInputLoader<Input>(
            // avoid using initializer_list to reduce stack pressure
            []() {
              std::vector<std::pair<std::string, QTypePtr>> result(2);
              // Note: `result[i] =` is more binary size efficient as
              // `emplace_back`.
              result[0] = {R"RL_CODEGEN_DELIM(a3)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_0>()};
              result[1] = {R"RL_CODEGEN_DELIM(a5)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_1>()};
              return result;
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         this->types_in_order(), output_slots));
    AccessorsSlotSetter fn;
    for (size_t i = 0; i != 2; ++i) {
      auto slot = optional_slots[i];
      fn.offsets[i] = slot.has_value() ? slot->byte_offset() : kSkippedOffset;
      if (slot.has_value()) {
        fn.offset_group_present[i / 8] = true;
      }
    }
    return BoundInputLoader<Input>(fn);
  }
};
}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<InputLoader<Input>*>(new AccessorsLoader())))
          ->release();
  return impl;
}
}  // namespace

namespace {

constexpr auto GetAllShardsInputLoader =
    ::aaa_GetLoader1ImplNamespace::GetCollectionInputLoader;

}  // namespace
}  // namespace aaa_GetLoader1ImplNamespace

namespace aaa {

std::unique_ptr<InputLoader<::std::array<int, 10>>> GetLoader1() {
  return MakeNotOwningInputLoader(
      ::aaa_GetLoader1ImplNamespace::GetAllShardsInputLoader());
}

}  // namespace aaa

namespace bbb_GetLoader2ImplNamespace {

using Input = ::std::array<float, 5>;

namespace {
namespace {
// Special value to mark not requested slot.
constexpr size_t kSkippedOffset = std::numeric_limits<size_t>::max();

constexpr auto accessor_lambda_0 = [](const auto& input) { return input[2]; };
using AccessorResultType_0 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_0), Input>;

constexpr auto accessor_lambda_1 = [](const auto& input) { return input[3]; };
using AccessorResultType_1 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_1), Input>;

// Calling all accessors and put results to the frame.
struct AccessorsSlotSetter {
  // kSkippedOffset means a skipped slot
  size_t offsets[2];
  // true iff at least one slot in the group of size 8 is present
  bool offset_group_present[1] = {false};

  Status operator()(const Input& input, FramePtr frame,
                    RawBufferFactory* factory) const {
    if (offset_group_present[0]) {
      if (size_t offset = offsets[0]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_0, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_0>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[1]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_1, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_1>::UnsafeSlotFromOffset(offset)));
      }
    }
    return OkStatus();
  }
};

// InputLoader based on accessors.
class AccessorsLoader final : public ::arolla::StaticInputLoader<Input> {
 public:
  AccessorsLoader()
      : ::arolla::StaticInputLoader<Input>(
            // avoid using initializer_list to reduce stack pressure
            []() {
              std::vector<std::pair<std::string, QTypePtr>> result(2);
              // Note: `result[i] =` is more binary size efficient as
              // `emplace_back`.
              result[0] = {R"RL_CODEGEN_DELIM(a2)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_0>()};
              result[1] = {R"RL_CODEGEN_DELIM(a3)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_1>()};
              return result;
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         this->types_in_order(), output_slots));
    AccessorsSlotSetter fn;
    for (size_t i = 0; i != 2; ++i) {
      auto slot = optional_slots[i];
      fn.offsets[i] = slot.has_value() ? slot->byte_offset() : kSkippedOffset;
      if (slot.has_value()) {
        fn.offset_group_present[i / 8] = true;
      }
    }
    return BoundInputLoader<Input>(fn);
  }
};
}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<InputLoader<Input>*>(new AccessorsLoader())))
          ->release();
  return impl;
}
}  // namespace

namespace {

constexpr auto GetAllShardsInputLoader =
    ::bbb_GetLoader2ImplNamespace::GetCollectionInputLoader;

}  // namespace
}  // namespace bbb_GetLoader2ImplNamespace

namespace bbb {

std::unique_ptr<InputLoader<::std::array<float, 5>>> GetLoader2() {
  return MakeNotOwningInputLoader(
      ::bbb_GetLoader2ImplNamespace::GetAllShardsInputLoader());
}

}  // namespace bbb
