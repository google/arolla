// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// //arolla/codegen/io/testing:test_scalar_accessor_with_default_value_input_loader

#include <memory>

#include "arolla/codegen/io/multi_loader.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/test.pb.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/util/map.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetSingleValueWithDefaultProtoLoaderImplNamespace {

using Input = ::testing_namespace::Root;

namespace {
namespace {
namespace single_value_protopath {

using ::arolla::codegen::io::kSkippedOffset;

// In this namespace protopath inputs with `OptionalValue` and `DenseArrayShape`
// are being loaded.

using HierarchicalSingleValueRequestedInputs =
    ::arolla::codegen::io::HierarchicalSingleValueRequestedInputsData<
        /*kLeafCount=*/6,
        /*kNodeCount=*/12>;

// Provides access to the output pointers for each leaf.
class OutputProvider {
 public:
  const HierarchicalSingleValueRequestedInputs* requested_inputs;
  FramePtr frame;

 public:
  // protopath=`inner/root_reference/inner/a` name=`a`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable0(size_t offset) const {
    using value_type = std::decay_t<decltype(std::declval<const Input&>()
                                                 .inner()
                                                 .root_reference()
                                                 .inner()
                                                 .a())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[0], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`inner/inner2/root_reference/x_float` name=`xf3`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable1(size_t offset) const {
    using result_type = float;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[1], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`inner/inner2/root_reference/x_float` name=`xf4`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable2(size_t offset) const {
    using result_type = float;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[2], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`inner/inner2/root_reference/x` name=`xrr`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable3(size_t offset) const {
    using value_type = std::decay_t<decltype(std::declval<const Input&>()
                                                 .inner()
                                                 .inner2()
                                                 .root_reference()
                                                 .x())>;
    using result_type =
        HierarchicalSingleValueRequestedInputs::value_type<value_type>;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[3], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x` name=`x0`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable4(size_t offset) const {
    using result_type = int32_t;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[4], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }

  // protopath=`x` name=`x1`
  ABSL_ATTRIBUTE_ALWAYS_INLINE auto* GetMutable5(size_t offset) const {
    using result_type = int32_t;
    DCHECK_NE(requested_inputs->common.leaf_frame_offsets[5], kSkippedOffset);
    return frame.GetMutable(
        ::arolla::FrameLayout::Slot<result_type>::UnsafeSlotFromOffset(offset));
  }
};

using ResultType_0 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable0(0))>>;
using ResultType_1 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable1(0))>>;
using ResultType_2 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable2(0))>>;
using ResultType_3 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable3(0))>>;
using ResultType_4 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable4(0))>>;
using ResultType_5 = std::decay_t<std::remove_pointer_t<
    decltype(std::declval<OutputProvider>().GetMutable5(0))>>;

// Set all optional values under the node as missed.
void SetAllOptionalMissed(
    const HierarchicalSingleValueRequestedInputs& requested_inputs,
    FramePtr frame, size_t node_intermediate_id) {
  const auto& clear_info =
      requested_inputs.node_optional_clear_infos[node_intermediate_id];
  for (size_t i = clear_info.range_begin; i != clear_info.range_end; ++i) {
    *frame.GetMutable(::arolla::FrameLayout::Slot<bool>::UnsafeSlotFromOffset(
        requested_inputs.requested_offsets[i])) = false;
  }
}

// SetAllToDefaultValues* functions set all leaves with default value.
// Assuming that top node is requested.

// protopath=`inner/inner2/root_reference`
void SetAllToDefaultValues2(const OutputProvider& outputs, FramePtr frame) {
  // protopath=`inner/inner2/root_reference/x_float` name=`xf3`
  if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[1];
      offset != kSkippedOffset) {
    *outputs.GetMutable1(offset) = 3.0f;
  }
  // protopath=`inner/inner2/root_reference/x_float` name=`xf4`
  if (size_t offset = outputs.requested_inputs->common.leaf_frame_offsets[2];
      offset != kSkippedOffset) {
    *outputs.GetMutable2(offset) = 4.0f;
  }
}

// protopath=`inner/inner2`
void SetAllToDefaultValues3(const OutputProvider& outputs, FramePtr frame) {
  SetAllToDefaultValues2(outputs, frame);
}

// protopath=`inner`
void SetAllToDefaultValues4(const OutputProvider& outputs, FramePtr frame) {
  if (outputs.requested_inputs->common.node_requested[3]) {
    SetAllToDefaultValues3(outputs, frame);
  }
}

// Traverse the proto and put results for all single values to the frame.
class SlotSetter {
 public:
  void CollectResults(const Input& input, const OutputProvider& outputs) {
    const Input& tmp_5 = input;

    // protopath=`inner`
    [&]() {
      if (!outputs.requested_inputs->common.node_requested[4]) {
        return;
      }
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_5, inner))) {
        SetAllOptionalMissed(*outputs.requested_inputs, outputs.frame, 4);
        SetAllToDefaultValues4(outputs, outputs.frame);
        return;
      }
      const auto& tmp_4 = tmp_5.inner();
      // protopath=`inner/root_reference`
      [&]() {
        if (!outputs.requested_inputs->common.node_requested[1]) {
          return;
        }
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_4, root_reference))) {
          SetAllOptionalMissed(*outputs.requested_inputs, outputs.frame, 1);
          return;
        }
        const auto& tmp_1 = tmp_4.root_reference();
        // protopath=`inner/root_reference/inner`
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_1, inner))) {
          SetAllOptionalMissed(*outputs.requested_inputs, outputs.frame, 0);
          return;
        }
        const auto& tmp_0 = tmp_1.inner();
        // protopath=`inner/root_reference/inner/a` name=`a`
        if (size_t offset =
                outputs.requested_inputs->common.leaf_frame_offsets[0];
            offset != kSkippedOffset) {
          if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_0, a))) {
            outputs.GetMutable0(offset)->present = false;
            return;
          }
          auto* output = outputs.GetMutable0(offset);
          output->present = true;
          output->value = ::arolla::proto::ToArollaCompatibleType(tmp_0.a());
        }
      }();
      // protopath=`inner/inner2`
      [&]() {
        if (!outputs.requested_inputs->common.node_requested[3]) {
          return;
        }
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_4, inner2))) {
          SetAllOptionalMissed(*outputs.requested_inputs, outputs.frame, 3);
          SetAllToDefaultValues3(outputs, outputs.frame);
          return;
        }
        const auto& tmp_3 = tmp_4.inner2();
        // protopath=`inner/inner2/root_reference`
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_3, root_reference))) {
          SetAllOptionalMissed(*outputs.requested_inputs, outputs.frame, 2);
          SetAllToDefaultValues2(outputs, outputs.frame);
          return;
        }
        const auto& tmp_2 = tmp_3.root_reference();
        // protopath=`inner/inner2/root_reference/x_float` name=`xf3`
        [&]() {
          if (size_t offset =
                  outputs.requested_inputs->common.leaf_frame_offsets[1];
              offset != kSkippedOffset) {
            if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, x_float))) {
              *outputs.GetMutable1(offset) = 3.0f;
              return;
            }
            auto* output = outputs.GetMutable1(offset);
            *output = tmp_2.x_float();
          }
        }();
        // protopath=`inner/inner2/root_reference/x_float` name=`xf4`
        [&]() {
          if (size_t offset =
                  outputs.requested_inputs->common.leaf_frame_offsets[2];
              offset != kSkippedOffset) {
            if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, x_float))) {
              *outputs.GetMutable2(offset) = 4.0f;
              return;
            }
            auto* output = outputs.GetMutable2(offset);
            *output = tmp_2.x_float();
          }
        }();
        // protopath=`inner/inner2/root_reference/x` name=`xrr`
        [&]() {
          if (size_t offset =
                  outputs.requested_inputs->common.leaf_frame_offsets[3];
              offset != kSkippedOffset) {
            if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_2, x))) {
              outputs.GetMutable3(offset)->present = false;
              return;
            }
            auto* output = outputs.GetMutable3(offset);
            output->present = true;
            output->value = ::arolla::proto::ToArollaCompatibleType(tmp_2.x());
          }
        }();
      }();
    }();
    // protopath=`x` name=`x0`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[4];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_5, x))) {
          *outputs.GetMutable4(offset) = 0;
          return;
        }
        auto* output = outputs.GetMutable4(offset);
        *output = tmp_5.x();
      }
    }();
    // protopath=`x` name=`x1`
    [&]() {
      if (size_t offset =
              outputs.requested_inputs->common.leaf_frame_offsets[5];
          offset != kSkippedOffset) {
        if (!(AROLLA_PROTO3_COMPATIBLE_HAS(tmp_5, x))) {
          *outputs.GetMutable5(offset) = 1;
          return;
        }
        auto* output = outputs.GetMutable5(offset);
        *output = tmp_5.x();
      }
    }();
  }
};

// InputLoader for all single value protopathes.
class Loader final : public ::arolla::StaticInputLoader<Input> {
 public:
  Loader()
      : ::arolla::StaticInputLoader<Input>(
            // Use special builder to reduce binary size and stack pressure.
            []() {
              ::arolla::codegen::NamedQTypeVectorBuilder builder;
              builder.AddFromCommonPrefixWithPrevious(
                  // a
                  1, R"RL_CODEGEN_DELIM(a)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_0>());
              builder.AddFromCommonPrefixWithPrevious(
                  // xf3
                  3, R"RL_CODEGEN_DELIM(xf3)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_1>());
              builder.AddFromCommonPrefixWithPrevious(
                  // xf4
                  3, R"RL_CODEGEN_DELIM(4)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_2>());
              builder.AddFromCommonPrefixWithPrevious(
                  // xrr
                  3, R"RL_CODEGEN_DELIM(rr)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_3>());
              builder.AddFromCommonPrefixWithPrevious(
                  // x0
                  2, R"RL_CODEGEN_DELIM(0)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_4>());
              builder.AddFromCommonPrefixWithPrevious(
                  // x1
                  2, R"RL_CODEGEN_DELIM(1)RL_CODEGEN_DELIM",
                  ::arolla::GetQType<ResultType_5>());
              return std::move(builder).Build();
            }()) {}

 private:
  auto CreateProtopathTree() const {
    return []() {
      std::vector<std::vector<size_t>> tree(12);
      tree[1] = {0};
      tree[2] = {1};
      tree[6] = {3, 4, 5};
      tree[7] = {6};
      tree[8] = {2, 7};
      tree[11] = {8, 9, 10};
      return tree;
    }();
  }

  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(
        auto optional_slots,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), output_slots));
    // Allocate on heap to reduce stack pressure.
    auto inputs = std::make_unique<HierarchicalSingleValueRequestedInputs>();
    auto tree = CreateProtopathTree();
    CreateHierarchicalSingleValueRequestedInputs(optional_slots,
                                                 /*size_leaves=*/{}, tree,
                                                 inputs.get());
    return BoundInputLoader<Input>(
        [inputs = std::move(inputs)](const Input& input, FramePtr frame,
                                     RawBufferFactory*) {
          OutputProvider output_getter{inputs.get(), frame};
          SlotSetter slot_setter;
          slot_setter.CollectResults(input, output_getter);
          return OkStatus();
        });
  }
};

}  // namespace single_value_protopath

}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(static_cast<InputLoader<Input>*>(
              new single_value_protopath::Loader())))
          ->release();
  return impl;
}
}  // namespace

namespace {

constexpr auto GetAllShardsInputLoader =
    ::my_namespace_GetSingleValueWithDefaultProtoLoaderImplNamespace::
        GetCollectionInputLoader;

}  // namespace
}  // namespace my_namespace_GetSingleValueWithDefaultProtoLoaderImplNamespace

namespace my_namespace {

std::unique_ptr<InputLoader<::testing_namespace::Root>>
GetSingleValueWithDefaultProtoLoader() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetSingleValueWithDefaultProtoLoaderImplNamespace::
          GetAllShardsInputLoader());
}

}  // namespace my_namespace
