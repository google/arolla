// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// //arolla/codegen/io/testing:test_wildcard_proto_input_loader

#include <memory>

#include "arolla/codegen/io/testing/test_proto_qtype.h"
#include "arolla/dense_array/dense_array.h"
#include "arolla/dense_array/qtype/types.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/proto/testing/test.pb.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/util/map.h"

namespace {

using ::arolla::InputLoader;
using ::arolla::WildcardInputLoader;

using Input = ::testing_namespace::Root;

constexpr auto accessor_lambda_0 =
    [](const ::testing_namespace::Root& input, absl::string_view feature_key,
       ::arolla::proto::arolla_optional_value_t<
           decltype(input.map_string_inner().at(feature_key).a())>* output) {
      output->present = false;
      if (!(input.map_string_inner().count(feature_key) > 0)) {
        return;
      }
      const auto& val_0 = input.map_string_inner().at(feature_key);
      if (!(AROLLA_PROTO3_COMPATIBLE_HAS(val_0, a))) {
        return;
      }
      const auto& final_result = val_0.a();
      output->present = true;
      output->value = final_result;
    };
using AccessorResultType_0 =
    ::arolla::WildcardAccessorResultType<decltype(accessor_lambda_0), Input,
                                         std::string>;
constexpr auto accessor_lambda_1 = [](const ::testing_namespace::Root& input,
                                      absl::string_view feature_key,
                                      ::arolla::RawBufferFactory* factory) {
  using proto_value_type =
      std::decay_t<decltype(input.map_string_inner().at(feature_key).as(0))>;
  using value_type = ::arolla::proto::arolla_single_value_t<proto_value_type>;
  size_t total_size = [&](const auto& input) {
    size_t total_size = 0;
    size_t final_size = [&]() {
      if (!(input.map_string_inner().count(feature_key) > 0)) {
        return 0;
      }
      const auto& final_size_last = input.map_string_inner().at(feature_key);
      return final_size_last.as().size();
    }();
    total_size += final_size;
    return total_size;
  }(input);
  using result_type = ::arolla::DenseArray<value_type>;
  typename ::arolla::Buffer<value_type>::Builder bldr(total_size, factory);
  auto inserter = bldr.GetInserter();
  int64_t id = 0;
  ::arolla::bitmap::AlmostFullBuilder bitmap_bldr(total_size, factory);
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
    if (!(input.map_string_inner().count(feature_key) > 0)) {
      continue;
    }
    const auto& value_0_last = input.map_string_inner().at(feature_key);
    for (const auto& value_0 : value_0_last.as()) {
      id++;
      inserter.Add(value_0);
    }
  }
  return result_type{std::move(bldr).Build(), std::move(bitmap_bldr).Build()};
};
using AccessorResultType_1 =
    ::arolla::WildcardAccessorResultType<decltype(accessor_lambda_1), Input,
                                         std::string>;
constexpr auto accessor_lambda_2 =
    [](const ::testing_namespace::Root& input, absl::string_view feature_key,
       ::arolla::proto::arolla_optional_value_t<decltype((
           &(input.map_string_inner().at(feature_key))))>* output) {
      output->present = false;
      if (!(input.map_string_inner().count(feature_key) > 0)) {
        return;
      }
      const auto& val_0 = input.map_string_inner().at(feature_key);
      const auto& final_result = (&(val_0));
      output->present = true;
      output->value = final_result;
    };
using AccessorResultType_2 =
    ::arolla::WildcardAccessorResultType<decltype(accessor_lambda_2), Input,
                                         std::string>;
constexpr auto accessor_lambda_3 =
    [](const ::testing_namespace::Root& input, absl::string_view feature_key,
       ::arolla::proto::arolla_optional_value_t<decltype(input.map_int().at(
           feature_key))>* output) {
      output->present = false;
      if (!(input.map_int().count(feature_key) > 0)) {
        return;
      }
      const auto& final_result = input.map_int().at(feature_key);
      output->present = true;
      output->value = final_result;
    };
using AccessorResultType_3 =
    ::arolla::WildcardAccessorResultType<decltype(accessor_lambda_3), Input,
                                         std::string>;
constexpr auto accessor_lambda_4 =
    [](const ::testing_namespace::Root& input, absl::string_view feature_key,
       ::arolla::proto::arolla_optional_value_t<decltype(input.map_int().at(
           feature_key))>* output) {
      output->present = false;
      if (!(input.map_int().count(feature_key) > 0)) {
        return;
      }
      const auto& final_result = input.map_int().at(feature_key);
      output->present = true;
      output->value = final_result;
    };
using AccessorResultType_4 =
    ::arolla::WildcardAccessorResultType<decltype(accessor_lambda_4), Input,
                                         std::string>;
constexpr auto accessor_lambda_5 =
    [](const ::testing_namespace::Root& input, absl::string_view feature_key,
       ::arolla::proto::arolla_optional_value_t<decltype(input.map_int().at(
           feature_key))>* output) {
      output->present = false;
      if (!(input.map_int().count(feature_key) > 0)) {
        return;
      }
      const auto& final_result = input.map_int().at(feature_key);
      output->present = true;
      output->value = final_result;
    };
using AccessorResultType_5 =
    ::arolla::WildcardAccessorResultType<decltype(accessor_lambda_5), Input,
                                         std::string>;

}  // namespace

namespace my_namespace {

absl::StatusOr<std::unique_ptr<InputLoader<Input>>>
GetWildcardMapInnerAProtoLoader() {
  return WildcardInputLoader<Input>::Build(
      accessor_lambda_0,
      absl::ParsedFormat<'s'>(
          R"accessor____name(/map_string_inner["%s"]/a)accessor____name"));
}

}  // namespace my_namespace
namespace my_namespace {

absl::StatusOr<std::unique_ptr<InputLoader<Input>>>
GetWildcardMapInnerAsProtoLoader() {
  return WildcardInputLoader<Input>::Build(
      accessor_lambda_1,
      absl::ParsedFormat<'s'>(
          R"accessor____name(/map_string_inner["%s"]/as)accessor____name"));
}

}  // namespace my_namespace
namespace my_namespace {

absl::StatusOr<std::unique_ptr<InputLoader<Input>>>
GetWildcardMapInnerPtrProtoLoader() {
  return WildcardInputLoader<Input>::Build(
      accessor_lambda_2,
      absl::ParsedFormat<'s'>(
          R"accessor____name(/map_string_inner["%s"])accessor____name"));
}

}  // namespace my_namespace
namespace my_namespace {

absl::StatusOr<std::unique_ptr<InputLoader<Input>>>
GetWildcardMapIntNoRenamingProtoLoader() {
  return WildcardInputLoader<Input>::Build(
      accessor_lambda_3,
      absl::ParsedFormat<'s'>(R"accessor____name(%s)accessor____name"));
}

}  // namespace my_namespace
namespace my_namespace {

absl::StatusOr<std::unique_ptr<InputLoader<Input>>>
GetWildcardMapIntNoRenamingProtoLoader2() {
  return WildcardInputLoader<Input>::Build(
      accessor_lambda_4,
      absl::ParsedFormat<'s'>(R"accessor____name(%s)accessor____name"));
}

}  // namespace my_namespace
namespace my_namespace {

absl::StatusOr<std::unique_ptr<InputLoader<Input>>>
GetWildcardMapIntProtoLoader() {
  return WildcardInputLoader<Input>::Build(
      accessor_lambda_5,
      absl::ParsedFormat<'s'>(
          R"accessor____name(/map_int["%s"])accessor____name"));
}

}  // namespace my_namespace
