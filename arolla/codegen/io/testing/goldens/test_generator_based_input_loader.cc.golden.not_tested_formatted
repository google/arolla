// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// //arolla/codegen/io/testing:test_generator_based_input_loader

#include <memory>

#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/accessors_input_loader.h"
#include "arolla/io/input_loader.h"
#include "arolla/io/proto_types/types.h"
#include "arolla/io/wildcard_input_loader.h"
#include "arolla/qtype/base_types.h"

namespace {
using ::absl::OkStatus;
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundInputLoader;
using ::arolla::ChainInputLoader;
using ::arolla::FramePtr;
using ::arolla::GetQType;
using ::arolla::InputLoader;
using ::arolla::QTypePtr;
using ::arolla::RawBufferFactory;
using ::arolla::TypedSlot;
using ::arolla::WildcardInputLoader;
}  // namespace

namespace my_namespace_GetAccessorsGeneratedArrayLoaderImplNamespace {

using Input = ::std::array<int, 10>;

namespace {
namespace {
// Special value to mark not requested slot.
constexpr size_t kSkippedOffset = std::numeric_limits<size_t>::max();

constexpr auto accessor_lambda_0 = [](const auto& input) { return input[2]; };
using AccessorResultType_0 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_0), Input>;

constexpr auto accessor_lambda_1 = [](const auto& input) { return input[3]; };
using AccessorResultType_1 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_1), Input>;

constexpr auto accessor_lambda_2 = [](const auto& input) { return input[4]; };
using AccessorResultType_2 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_2), Input>;

constexpr auto accessor_lambda_3 = [](const auto& input) { return input[5]; };
using AccessorResultType_3 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_3), Input>;

constexpr auto accessor_lambda_4 = [](const auto& input) { return input[6]; };
using AccessorResultType_4 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_4), Input>;

constexpr auto accessor_lambda_5 = [](const auto& input) { return input[1]; };
using AccessorResultType_5 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_5), Input>;

constexpr auto accessor_lambda_6 = [](const auto& input) { return input[0]; };
using AccessorResultType_6 =
    ::arolla::InputLoaderAccessorResultType<decltype(accessor_lambda_6), Input>;

// Calling all accessors and put results to the frame.
struct AccessorsSlotSetter {
  // kSkippedOffset means a skipped slot
  size_t offsets[7];
  // true iff at least one slot in the group of size 8 is present
  bool offset_group_present[1] = {false};

  Status operator()(const Input& input, FramePtr frame,
                    RawBufferFactory* factory) const {
    if (offset_group_present[0]) {
      if (size_t offset = offsets[0]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_0, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_0>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[1]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_1, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_1>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[2]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_2, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_2>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[3]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_3, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_3>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[4]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_4, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_4>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[5]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_5, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_5>::UnsafeSlotFromOffset(offset)));
      }
      if (size_t offset = offsets[6]; offset != kSkippedOffset) {
        ::arolla::InvokeInputLoaderAccessor(
            accessor_lambda_6, input, factory,
            frame.GetMutable(
                ::arolla::FrameLayout::Slot<
                    AccessorResultType_6>::UnsafeSlotFromOffset(offset)));
      }
    }
    return OkStatus();
  }
};

// InputLoader based on accessors.
class AccessorsLoader final : public ::arolla::StaticInputLoader<Input> {
 public:
  AccessorsLoader()
      : ::arolla::StaticInputLoader<Input>(
            // avoid using initializer_list to reduce stack pressure
            []() {
              std::vector<std::pair<std::string, QTypePtr>> result(7);
              // Note: `result[i] =` is more binary size efficient as
              // `emplace_back`.
              result[0] = {R"RL_CODEGEN_DELIM(a_2)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_0>()};
              result[1] = {R"RL_CODEGEN_DELIM(a_3)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_1>()};
              result[2] = {R"RL_CODEGEN_DELIM(a_4)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_2>()};
              result[3] = {R"RL_CODEGEN_DELIM(f_5)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_3>()};
              result[4] = {R"RL_CODEGEN_DELIM(f_6)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_4>()};
              result[5] = {R"RL_CODEGEN_DELIM(one)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_5>()};
              result[6] = {R"RL_CODEGEN_DELIM(zero)RL_CODEGEN_DELIM",
                           ::arolla::GetQType<AccessorResultType_6>()};
              return result;
            }()) {}

 private:
  StatusOr<BoundInputLoader<Input>> BindImpl(
      const absl::flat_hash_map<std::string, TypedSlot>& output_slots)
      const final {
    ASSIGN_OR_RETURN(auto optional_slots,
                     ::arolla::MaybeFindSlotsAndVerifyTypes(
                         this->types_in_order(), output_slots));
    AccessorsSlotSetter fn;
    for (size_t i = 0; i != 7; ++i) {
      auto slot = optional_slots[i];
      fn.offsets[i] = slot.has_value() ? slot->byte_offset() : kSkippedOffset;
      if (slot.has_value()) {
        fn.offset_group_present[i / 8] = true;
      }
    }
    return BoundInputLoader<Input>(fn);
  }
};
}  // namespace

// Returns ChainInputLoader: Accessors, Single- and Multi-value proto.
const InputLoader<Input>* GetCollectionInputLoader() {
  static const InputLoader<Input>* impl =
      ChainInputLoader<Input>::Build(
          // Not using make_unique to avoid binary size blowup.
          ::arolla::InputLoaderPtr<Input>(
              static_cast<InputLoader<Input>*>(new AccessorsLoader())))
          ->release();
  return impl;
}
}  // namespace

namespace {

constexpr auto GetAllShardsInputLoader =
    ::my_namespace_GetAccessorsGeneratedArrayLoaderImplNamespace::
        GetCollectionInputLoader;

}  // namespace
}  // namespace my_namespace_GetAccessorsGeneratedArrayLoaderImplNamespace

namespace my_namespace {

std::unique_ptr<InputLoader<::std::array<int, 10>>>
GetAccessorsGeneratedArrayLoader() {
  return MakeNotOwningInputLoader(
      ::my_namespace_GetAccessorsGeneratedArrayLoaderImplNamespace::
          GetAllShardsInputLoader());
}

}  // namespace my_namespace
