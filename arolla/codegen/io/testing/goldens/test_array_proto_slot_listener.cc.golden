// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_array_proto_slot_listener

#include <functional>
#include <optional>

#include "arolla/codegen/io/multi_loader.h"
#include "arolla/dense_array/dense_array.h"
#include "arolla/dense_array/qtype/types.h"
#include "arolla/proto/test.pb.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/util/map.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/slot_listener.h"
#include "arolla/util/status.h"
#include "arolla/memory/frame.h"
#include "arolla/io/chain_slot_listener.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/qtype/typed_slot.h"
#include "absl/strings/string_view.h"
#include "arolla/util/meta.h"

namespace {
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundSlotListener;
using ::arolla::ChainSlotListener;
using ::arolla::ConstFramePtr;
using ::arolla::FrameLayout;
using ::arolla::GetQType;
using ::arolla::QTypePtr;
using ::arolla::SlotListener;
using ::arolla::TypedSlot;
}

namespace my_namespace_GetArrayProtoSlotListenerImplNamespace {

using Output = ::testing_namespace::Root;

namespace {
namespace {
namespace accessors_listener {

template <class Fn>
using accessor_lambda_result_t = std::decay_t<::arolla::meta::head_t<
    typename ::arolla::meta::function_traits<Fn>::arg_types>>;



constexpr auto accessor_lambda_0 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).as(0))>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/as[0]:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          if (!(value_0.as().size() > 0)) { ++id; continue; }
          value_0.set_as(0, proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_0_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_0)>;
using accessor_lambda_0_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_0)>::return_type, absl::Status>;
using output_slot_0_t = FrameLayout::Slot<
    accessor_lambda_0_result_t>;

constexpr auto accessor_lambda_1 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).a())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/a:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
          value_0.set_a(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_1_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_1)>;
using accessor_lambda_1_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_1)>::return_type, absl::Status>;
using output_slot_1_t = FrameLayout::Slot<
    accessor_lambda_1_result_t>;

constexpr auto accessor_lambda_2 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).inners2(0).z())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/inners2[0]/z:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
  if (!(value_0.inners2().size() > 0)) { ++id; continue; }
  auto& final_item = value_0.mutable_inners2()->at(0);
          final_item.set_z(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_2_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_2)>;
using accessor_lambda_2_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_2)>::return_type, absl::Status>;
using output_slot_2_t = FrameLayout::Slot<
    accessor_lambda_2_result_t>;

constexpr auto accessor_lambda_3 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inner().inners2(0).z())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS(input, inner))) { return 0; }
  const auto& final_size_last = input.inner();
return final_size_last.inners2().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inner/inners2/z:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
  if (!(AROLLA_PROTO3_COMPATIBLE_HAS((*output_ptr), inner))) { continue; }
  auto& value_0_last = *(*output_ptr).mutable_inner();
for (auto& value_0 : *value_0_last.mutable_inners2()) {
    if (input.present(id)) {
          value_0.set_z(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_3_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_3)>;
using accessor_lambda_3_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_3)>::return_type, absl::Status>;
using output_slot_3_t = FrameLayout::Slot<
    accessor_lambda_3_result_t>;

constexpr auto accessor_lambda_4 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).inners2(0).z())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (const auto& value_0 : input.inners()) {
size_t final_size = [&]() {
return value_0.inners2().size(); }();
total_size += final_size;
}}
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/inners2/z:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
for (auto& value_1 : *value_0.mutable_inners2()) {
    if (input.present(id)) {
          value_1.set_z(proto_value_type(input.values[id]));
        }
        ++id;
  }}}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_4_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_4)>;
using accessor_lambda_4_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_4)>::return_type, absl::Status>;
using output_slot_4_t = FrameLayout::Slot<
    accessor_lambda_4_result_t>;

constexpr auto accessor_lambda_5 = [](auto output_type_meta_fn) constexpr {
using output_type = typename decltype(output_type_meta_fn)::type;
using proto_value_type = std::decay_t<decltype(std::declval<output_type>().inners(0).root_reference().map_string_inner().at("a").a())>;
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {
    size_t total_size = [](const auto& input) {
    size_t total_size = 0;
size_t final_size = [&]() {
return input.inners().size(); }();
total_size += final_size;
return total_size;
  }(*output_ptr);
    if (total_size != input.size()) {
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name(/inners/root_reference/map_string_inner["a"]/a:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }
  size_t id = 0;
  for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {
for (auto& value_0 : *(*output_ptr).mutable_inners()) {
    if (input.present(id)) {
  auto& value_0_tmp_0 = *value_0.mutable_root_reference();
  auto& final_item = (*value_0_tmp_0.mutable_map_string_inner())["a"];
          final_item.set_a(proto_value_type(input.values[id]));
        }
        ++id;
  }}
  return absl::OkStatus();
  }; }(
    std::decay<Output>());
using accessor_lambda_5_result_t = accessor_lambda_result_t<
    decltype(accessor_lambda_5)>;
using accessor_lambda_5_has_status = std::is_same<
    typename ::arolla::meta::function_traits<
        decltype(accessor_lambda_5)>::return_type, absl::Status>;
using output_slot_5_t = FrameLayout::Slot<
    accessor_lambda_5_result_t>;

constexpr size_t kSkippedOffset = std::numeric_limits<size_t>::max();

struct SlotListenerLambdaCaller {
  size_t offsets[6];
  // true iff at least one slot in the group of size 8 is present
  bool offset_group_present[1] = {false};

  template <class Output>  // templated in order to trigger constexpr if
  Status operator()(ConstFramePtr frame, Output* output) const {
    if (offset_group_present[0]) {
      if (auto offset = offsets[0]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_0_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_0(
            frame.Get(
                output_slot_0_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_0(
            frame.Get(
                output_slot_0_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[1]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_1_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_1(
            frame.Get(
                output_slot_1_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_1(
            frame.Get(
                output_slot_1_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[2]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_2_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_2(
            frame.Get(
                output_slot_2_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_2(
            frame.Get(
                output_slot_2_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[3]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_3_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_3(
            frame.Get(
                output_slot_3_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_3(
            frame.Get(
                output_slot_3_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[4]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_4_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_4(
            frame.Get(
                output_slot_4_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_4(
            frame.Get(
                output_slot_4_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
      if (auto offset = offsets[5]; offset != kSkippedOffset) {
        if constexpr (accessor_lambda_5_has_status::value) {
          RETURN_IF_ERROR(accessor_lambda_5(
            frame.Get(
                output_slot_5_t::UnsafeSlotFromOffset(offset)),
            output));
        } else {
          accessor_lambda_5(
            frame.Get(
                output_slot_5_t::UnsafeSlotFromOffset(offset)),
            output);
        }
      }
    }
    return ::absl::OkStatus();
  }
};

class Listener final : public ::arolla::StaticSlotListener<Output> {
 public:
  Listener()
    :StaticSlotListener(
        // Use special builder to reduce binary size and stack pressure.
        []() {
          ::arolla::codegen::NamedQTypeVectorBuilder builder;
          builder.AddFromCommonPrefixWithPrevious(
              // in_array_as
              11,
              R"RL_CODEGEN_DELIM(in_array_as)RL_CODEGEN_DELIM",
              ::arolla::GetQType<accessor_lambda_0_result_t>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners__a
              9,
              R"RL_CODEGEN_DELIM(ners__a)RL_CODEGEN_DELIM",
              ::arolla::GetQType<accessor_lambda_1_result_t>());
          builder.AddFromCommonPrefixWithPrevious(
              // in_array_z
              10,
              R"RL_CODEGEN_DELIM(_array_z)RL_CODEGEN_DELIM",
              ::arolla::GetQType<accessor_lambda_2_result_t>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners2__z
              10,
              R"RL_CODEGEN_DELIM(ners2__z)RL_CODEGEN_DELIM",
              ::arolla::GetQType<accessor_lambda_3_result_t>());
          builder.AddFromCommonPrefixWithPrevious(
              // inners__inners2__z
              18,
              R"RL_CODEGEN_DELIM(__inners2__z)RL_CODEGEN_DELIM",
              ::arolla::GetQType<accessor_lambda_4_result_t>());
          builder.AddFromCommonPrefixWithPrevious(
              // in_map_a
              8,
              R"RL_CODEGEN_DELIM(_map_a)RL_CODEGEN_DELIM",
              ::arolla::GetQType<accessor_lambda_5_result_t>());
          return std::move(builder).Build();
        }()) {}

 private:
  StatusOr<BoundSlotListener<Output>> BindImpl(
      // The slots corresponding to this SlotListener's inputs.
      const absl::flat_hash_map<std::string, TypedSlot>& input_slots)
      const override {
    ASSIGN_OR_RETURN(
        std::vector<std::optional<TypedSlot>> input_slots_in_order,
        ::arolla::MaybeFindSlotsAndVerifyTypes(types_in_order(), input_slots));
    SlotListenerLambdaCaller fn;
    for (size_t i = 0; i != 6; ++i) {
      auto slot = input_slots_in_order[i];
      fn.offsets[i] = slot.has_value() ? slot->byte_offset() : kSkippedOffset;
      if (slot.has_value()) {
        fn.offset_group_present[i / 8] = true;
      }
    }
    return fn;
  }
};

}  // namespace accessors_listener
}  // namespace

const SlotListener<Output>*
GetCollectionSlotListener() {
  static const SlotListener<Output>* impl = ChainSlotListener<Output>::Build(
      std::make_unique<accessors_listener::Listener>()
      )->release();
  return impl;
}
}  // namespace
}  // namespace my_namespace_GetArrayProtoSlotListenerImplNamespace

namespace my_namespace {

std::unique_ptr<::arolla::SlotListener<::testing_namespace::Root>>
GetArrayProtoSlotListener() {
  return MakeNotOwningSlotListener(::my_namespace_GetArrayProtoSlotListenerImplNamespace::GetCollectionSlotListener());
}

}  // namespace my_namespace

