// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target: //arolla/codegen/io/testing:test_empty_slot_listener

#include <functional>
#include <optional>

#include "arolla/proto/test.pb.h"
#include "arolla/codegen/qtype_utils.h"
#include "arolla/io/slot_listener.h"
#include "arolla/util/status.h"
#include "arolla/memory/frame.h"
#include "arolla/io/chain_slot_listener.h"
#include "arolla/proto/types.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype.h"
#include "arolla/qtype/typed_slot.h"
#include "absl/strings/string_view.h"
#include "arolla/util/meta.h"

namespace {
using ::absl::Status;
using ::absl::StatusOr;
using ::arolla::BoundSlotListener;
using ::arolla::ChainSlotListener;
using ::arolla::ConstFramePtr;
using ::arolla::FrameLayout;
using ::arolla::GetQType;
using ::arolla::QTypePtr;
using ::arolla::SlotListener;
using ::arolla::TypedSlot;
}

namespace my_namespace_GetEmptySlotListenerImplNamespace {

using Output = ::testing_namespace::Root;

namespace {
namespace {

}  // namespace

const SlotListener<Output>*
GetCollectionSlotListener() {
  static const SlotListener<Output>* impl = ChainSlotListener<Output>::Build(
      )->release();
  return impl;
}
}  // namespace
}  // namespace my_namespace_GetEmptySlotListenerImplNamespace

namespace my_namespace {

std::unique_ptr<::arolla::SlotListener<::testing_namespace::Root>>
GetEmptySlotListener() {
  return MakeNotOwningSlotListener(::my_namespace_GetEmptySlotListenerImplNamespace::GetCollectionSlotListener());
}

}  // namespace my_namespace

