# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Library for dealing with protopath parsing."""
from __future__ import annotations

import abc
import importlib
import itertools
import re
from typing import AbstractSet, Callable, List, Optional, Tuple, Dict, Iterable

from arolla.codegen.io import accessors
from arolla.codegen.io import array_generator
from arolla.codegen.io import cpp
from arolla.codegen.io import table
from google.protobuf import descriptor

# Name modifiers that convert default name to one that correspond to policy.
default_name_modifiers = {
    'default': lambda x: x,
    'single_underscore': lambda x: x[1:].replace('/', '_'),
    'double_underscore': lambda x: x[1:].replace('/', '__'),
    'leaf_only': lambda x: x if x.endswith('@size') else x.split('/')[-1],
}

_DYNAMIC_FEATURE_KEY = 'feature_key'
_FACTORY_ARG_NAME_KEY = 'factory'

_MANDATORY_INCLUDES = [
    cpp.Include('arolla/util/map.h'),
    cpp.Include('arolla/proto/types.h'),
]

# https://en.cppreference.com/w/cpp/keyword
_CPP_KEYWORDS = frozenset([
    #  go/keep-sorted start
    'alignas',
    'alignof',
    'and',
    'and_eq',
    'asm',
    'auto',
    'bitand',
    'bitor',
    'bool',
    'break',
    'case',
    'catch',
    'char',
    'char16_t',
    'char32_t',
    'class',
    'compl',
    'const',
    'const_cast',
    'constexpr',
    'continue',
    'decltype',
    'default',
    'delete',
    'double',
    'dynamic_cast',
    'else',
    'enum',
    'explicit',
    'export',
    'extern ',
    'false',
    'float',
    'for',
    'friend',
    'goto',
    'if',
    'inline',
    'int',
    'long',
    'mutable',
    'namespace',
    'new',
    'noexcept',
    'not',
    'not_eq',
    'nullptr',
    'operator',
    'or',
    'or_eq',
    'private',
    'protected',
    'public',
    'register',
    'reinterpret_cast',
    'return',
    'short',
    'signed',
    'sizeof',
    'static',
    'static_assert',
    'static_cast',
    'struct',
    'switch',
    'template',
    'this',
    'thread_local',
    'throw',
    'true',
    'try',
    'typedef',
    'typeid',
    'typename',
    'union',
    'unsigned',
    'using',
    'virtual',
    'void',
    'volatile',
    'wchar_t',
    'while',
    'xor',
    'xor_eq'
    #  go/keep-sorted end
])


def _cpp_getter_name(proto_field_name: str) -> str:
  """Returns name generated by C++ proto compiler."""
  getter = proto_field_name.lower()
  # reserved c++ keywords
  if getter in _CPP_KEYWORDS:
    getter += '_'
  return getter


def _single_input_lambda(
    body: str,
    *,
    capture_all: bool = False,
    input_type: str = 'auto',
    output_type: Optional[str] = None,
) -> str:
  """Returns lambda code for body assuming single input is called `input`."""
  capture = '&' if capture_all else ''
  output_str = '' if output_type is None else f',\n{output_type}* output'
  return f"""[{capture}](const {input_type}& input{output_str}) {{
    {body}
  }}"""


def _input_lambda_with_factory(
    body: str,
    *,
    input_type: str = 'auto',
) -> str:
  """Returns lambda code with two inputs: `input` and `factory`."""
  return (
      f'[](const {input_type}& input, '
      f'::arolla::RawBufferFactory* {_FACTORY_ARG_NAME_KEY}) {{ {body} }}'
  )


def _dynamic_input_lambda(
    body: str,
    *,
    input_type: str = 'auto',
    output_type: Optional[str] = None,
) -> str:
  """Returns code for body with wildcards."""
  output_str = '' if output_type is None else f',\n{output_type}* output'
  return (f'[](const {input_type}& input, absl::string_view '
          f'{_DYNAMIC_FEATURE_KEY}{output_str}) {{ {body} }}')


def _dynamic_input_lambda_with_factory(
    body: str,
    *,
    input_type: str = 'auto',
) -> str:
  """Returns code for body with wildcards."""
  return (
      f'[](const {input_type}& input, '
      f'absl::string_view {_DYNAMIC_FEATURE_KEY}, '
      f'::arolla::RawBufferFactory* {_FACTORY_ARG_NAME_KEY}) {{ {body} }}'
  )


def _mutable_lambda(body: str) -> str:
  """Returns code for body of the meta factory lambda to modify the output."""
  return '[](auto output_type_meta_fn) constexpr { %s }' % body


class MultipleValueElement(abc.ABC):
  """Interface for accessing repeated values or map from proto."""

  @abc.abstractmethod
  def __eq__(self, other: 'MultipleValueElement') -> bool:
    raise NotImplementedError()

  @abc.abstractmethod
  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    raise NotImplementedError()

  @abc.abstractmethod
  def access_for_type(self, var_name: str) -> str:
    raise NotImplementedError()

  @abc.abstractmethod
  def iteration_container(self,
                          input_name: str,
                          is_mutable: bool = False) -> str:
    """Returns code to construct container for iteration.

    Container should support range loop, `std::size`, `std::begin`, `std::end`.

    Values of the container could require post processing, see
    iteration_post_processing for more details.

    Args:
      input_name: name of the input variable
      is_mutable: whenever container need to be mutable.
    """
    raise NotImplementedError()

  def iteration_post_processing(self,
                                input_name: str,
                                loop_var: str,
                                is_mutable: bool = False) -> str:
    """Returns code for post processing loop variable or empty string.

    Empty string is returned if container values are actual elements.
    Otherwise returned code can be used as rvalue for assigning to the element.

    Args:
      input_name: name of the input variable
      loop_var: name of the loop variable used for iterating over container
      is_mutable: whenever result need to be mutable.
    """
    del input_name  # unused
    del loop_var  # unused
    del is_mutable  # unused
    return ''

  def open_loop(self,
                loop_var: str,
                input_name: str,
                is_mutable: bool = False) -> str:
    """Returns code to prepare repeated field and iterate over it.

    Args:
      loop_var: name of the variable to use for the loop
      input_name: name of the input variable
      is_mutable: whenever `loop_var` variable need to be mutable.
    """
    container = self.iteration_container(input_name, is_mutable)
    post_processing = self.iteration_post_processing(input_name,
                                                     f'{loop_var}_key',
                                                     is_mutable)
    const = 'const ' if not is_mutable else ''
    if not post_processing:
      return f'for ({const}auto& {loop_var} : {container}) {{\n'
    else:
      return f"""for ({const}auto& {loop_var}_key : {container}) {{
        {const}auto& {loop_var} = {post_processing};
"""

  @property
  @abc.abstractmethod
  def support_mutable(self) -> bool:
    raise NotImplementedError()

  @property
  @abc.abstractmethod
  def access_for_size(self) -> str:
    raise NotImplementedError()

  @abc.abstractmethod
  def resize(self, var_name: str, size: str) -> str:
    raise NotImplementedError()

  @abc.abstractmethod
  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    """Constructs new child TablePath."""
    raise NotImplementedError()

  @abc.abstractmethod
  def size_column_path(self, root: table.TablePath) -> table.ColumnPath:
    """Constructs ColumnPath for the size."""
    raise NotImplementedError()


class _OriginalInputContainerElement(MultipleValueElement):
  """Array element for the original input container."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a original container: ' + path_element)

  def __eq__(self, other: MultipleValueElement) -> bool:
    return isinstance(other, _OriginalInputContainerElement)

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    return '[:]'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return path_element == '[:]'

  @property
  def support_mutable(self) -> bool:
    return True

  def access_for_type(self, var_name: str) -> str:
    return f'{var_name}[0]'

  def iteration_container(self,
                          input_name: str,
                          is_mutable: bool = False) -> str:
    del is_mutable  # unused
    return input_name

  @property
  def access_for_size(self) -> str:
    return '.size()'

  def resize(self, var_name: str, size: str) -> str:
    raise NotImplementedError(
        'Original input container resize is not possible.')

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root

  def size_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return root.Size('')


class _RangeSliceElement(MultipleValueElement):
  """Path element representing [:] slice."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a range slice: ' + path_element)
    self._element = path_element[:-len('[:]')]
    self._getter = _cpp_getter_name(self._element)

  def __eq__(self, other: MultipleValueElement) -> bool:
    return isinstance(other,
                      _RangeSliceElement) and self._element == other._element

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    return self._element + '[:]'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return re.match(r'.*\[:\]$', path_element) is not None

  @property
  def support_mutable(self) -> bool:
    return True

  def access_for_type(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}(0)'

  def iteration_container(self,
                          input_name: str,
                          is_mutable: bool = False) -> str:
    if is_mutable:
      return f'*{input_name}.mutable_{self._getter}()'
    else:
      return f'{input_name}.{self._getter}()'

  @property
  def access_for_size(self) -> str:
    return '.' + self._getter + '().size()'

  def resize(self, var_name: str, size: str) -> str:
    return '::arolla::codegen::io::ResizeRepeatedProtoField(' + (
        f'{var_name}.mutable_{self._getter}(), {size})'
    )

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root.Child(self._element)

  def size_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return root.Size(self._element)


class _MapKeysAccessElement(MultipleValueElement):
  """Path element representing accessing to the map keys."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a map key access: ' + path_element)
    self._element = path_element[:-len('[:]@key')]
    self._getter = _cpp_getter_name(self._element)

  def __eq__(self, other: MultipleValueElement) -> bool:
    return isinstance(other,
                      _MapKeysAccessElement) and self._element == other._element

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    return self._element + '[:]@key'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return re.match(r'[^@]*\[:\]@key$', path_element) is not None

  @property
  def support_mutable(self) -> bool:
    return False

  def access_for_type(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}().begin()->first'

  def iteration_container(self,
                          input_name: str,
                          is_mutable: bool = False) -> str:
    if is_mutable:
      raise ValueError("Keys access doesn't support mutability.")
    else:
      return f'::arolla::SortedMapKeys({input_name}.{self._getter}())'

  @property
  def access_for_size(self) -> str:
    return f'.{self._getter}().size()'

  def resize(self, var_name: str, size: str) -> str:
    raise ValueError("Keys access doesn't support mutability.")

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root.Child(self._element).MapKeys()

  def size_column_path(self, root: table.TablePath) -> table.ColumnPath:
    raise NotImplementedError(
        'Size protopath should be created for the map itself.')


class _MapValuesAccessElement(MultipleValueElement):
  """Path element representing accessing to the map values."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a map values access: ' + path_element)
    self._element = path_element[:-len('[:]@value')]
    self._getter = _cpp_getter_name(self._element)

  def __eq__(self, other: MultipleValueElement) -> bool:
    return isinstance(
        other, _MapValuesAccessElement) and self._element == other._element

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    return self._element + '[:]@value'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return re.match(r'[^@]*\[:\]@value$', path_element) is not None

  @property
  def support_mutable(self) -> bool:
    return True

  def access_for_type(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}().begin()->second'

  def iteration_container(self,
                          input_name: str,
                          is_mutable: bool = False) -> str:
    return f'::arolla::SortedMapKeys({input_name}.{self._getter}())'

  def iteration_post_processing(  # pytype: disable=signature-mismatch  # overriding-return-type-checks
      self,
      input_name: str,
      loop_var: str,
      is_mutable: bool = False) -> Optional[str]:
    key_access_pattern = 'mutable_%s()->at' if is_mutable else '%s().at'
    key_access = key_access_pattern % self._getter
    return f'{input_name}.{key_access}({loop_var})'

  @property
  def access_for_size(self) -> str:
    return '.' + self._getter + '().size()'

  def resize(self, var_name: str, size: str) -> str:
    raise ValueError("Values access doesn't support resizing.")

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root.Child(self._element).MapValues()

  def size_column_path(self, root: table.TablePath) -> table.ColumnPath:
    raise NotImplementedError(
        'Size protopath should be created for the map itself.')


def _parse_multi_value_element(
    path_element: str) -> Optional[MultipleValueElement]:
  """Parse multi value element. Returns None on error."""
  if _OriginalInputContainerElement.is_this_type(path_element):
    return _OriginalInputContainerElement(path_element)
  if _RangeSliceElement.is_this_type(path_element):
    return _RangeSliceElement(path_element)
  if _MapKeysAccessElement.is_this_type(path_element):
    return _MapKeysAccessElement(path_element)
  if _MapValuesAccessElement.is_this_type(path_element):
    return _MapValuesAccessElement(path_element)
  return None


class SingleValueElement(abc.ABC):
  """Interface for accessing single value from proto."""

  @abc.abstractmethod
  def __eq__(self, other: 'SingleValueElement') -> bool:
    raise NotImplementedError()

  @abc.abstractmethod
  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    raise NotImplementedError()

  @abc.abstractmethod
  def access(self, var_name: str) -> str:
    raise NotImplementedError()

  @abc.abstractmethod
  def set_value_access(self, var_name: str, value: str) -> str:
    """Returns function name to set value to the field."""
    raise NotImplementedError()

  @abc.abstractmethod
  def mutable_access(self, var_name: str) -> str:
    """Returns code to access non-const reference of `var_name` element."""
    raise NotImplementedError()

  @abc.abstractmethod
  def can_continue_on_miss(self, *, is_mutable: bool) -> bool:
    """Return True if access can move further on missed value.

    Args:
      is_mutable: whenever access need to be mutable
    """
    raise NotImplementedError()

  @abc.abstractmethod
  def has_access(self, var_name: str) -> str:
    raise NotImplementedError()

  @abc.abstractmethod
  def access_cost(self) -> float:
    """Approximate cost in nanoseconds to access the value.

    Values are estimated by raw_proto_access_benchmarks.cc.
    """
    raise NotImplementedError()

  @property
  def is_wildcard(self) -> bool:
    return False

  @abc.abstractmethod
  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    """Constructs new child TablePath."""
    raise NotImplementedError()

  @abc.abstractmethod
  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    """Constructs new child ColumnPath."""
    raise NotImplementedError()


class _RegularElement(SingleValueElement):
  """Path element representing normal field access."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a regular field access: ' + path_element)
    self._element = path_element
    self._getter = _cpp_getter_name(self._element)

  def __eq__(self, other: SingleValueElement) -> bool:
    return (isinstance(other, _RegularElement) and
            self._element == other._element)

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    return f'{self._element}'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return path_element.isidentifier()

  def access(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}()'

  def set_value_access(self, var_name: str, value: str) -> str:
    return f'{var_name}.set_{self._getter}({value})'

  def mutable_access(self, var_name: str) -> str:
    return f'*{var_name}.mutable_{self._getter}()'

  def can_continue_on_miss(self, *, is_mutable: bool) -> bool:
    # We continue only on mutable.
    # This can cause issues with oneof proto fields, since
    # other set field will be removed.
    return is_mutable

  def has_access(self, var_name: str) -> str:
    return f'AROLLA_PROTO3_COMPATIBLE_HAS({var_name}, {self._getter})'

  def access_cost(self) -> float:
    return 0.4

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root.Child(table.FieldAccess(self._element))

  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return root.Column(table.FieldAccess(self._element))


class _DereferenceAccess(SingleValueElement):
  """Path element representing access by dereferencing a pointer."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a pointer dereference: ' + path_element)

  def __eq__(self, other: SingleValueElement) -> bool:
    return isinstance(other, _DereferenceAccess)

  def protopath_element(self) -> str:
    return '*'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return path_element == '*'

  def access(self, var_name: str) -> str:
    return f'(*({var_name}))'

  def set_value_access(self, var_name: str, value: str) -> str:
    return f'(*({var_name})) = {value}'

  def mutable_access(self, var_name: str) -> str:
    return f'(*({var_name}))'

  def can_continue_on_miss(self, *, is_mutable: bool) -> bool:
    del is_mutable
    return False

  def has_access(self, var_name: str) -> str:
    return f'{var_name} != nullptr'

  def access_cost(self) -> float:
    return 0.4

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root

  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return table.ColumnPath(str(root))


class _AddressOfAccess(SingleValueElement):
  """Path element representing access by taking a raw pointer."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not address of: ' + path_element)

  def __eq__(self, other: SingleValueElement) -> bool:
    return isinstance(other, _AddressOfAccess)

  def protopath_element(self) -> str:
    return '&'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return path_element == '&'

  def access(self, var_name: str) -> str:
    return f'(&({var_name}))'

  def has_access(self, var_name: str) -> str:
    return 'true'

  def set_value_access(self, var_name: str, value: str) -> str:
    raise NotImplementedError()

  def mutable_access(self, var_name: str) -> str:
    raise NotImplementedError()

  def can_continue_on_miss(self, *, is_mutable: bool) -> bool:
    del is_mutable
    return True

  def access_cost(self) -> float:
    return 0.4

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root

  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return table.ColumnPath(str(root))


class _StructFieldAccess(SingleValueElement):
  """Path element representing access to field in the struct."""

  _PREFIX = '&::'

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a struct field access: ' + path_element)
    self._element = path_element[len(self._PREFIX):]
    self._getter = _cpp_getter_name(self._element)

  def __eq__(self, other: SingleValueElement) -> bool:
    return isinstance(other,
                      _StructFieldAccess) and self._element == other._element

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    return f'{self._PREFIX}{self._element}'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return path_element.startswith(
        cls._PREFIX) and path_element[len(cls._PREFIX):].isidentifier()

  def access(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}'

  def set_value_access(self, var_name: str, value: str) -> str:
    return f'{var_name}.{self._getter} = {value}'

  def mutable_access(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}'

  def can_continue_on_miss(self, *, is_mutable: bool) -> bool:
    del is_mutable
    return True

  def has_access(self, var_name: str) -> str:
    return 'true'

  def access_cost(self) -> float:
    return 0.4

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root.Child(table.FieldAccess(self._element))

  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return root.Column(table.FieldAccess(self._element))


class _IndexAccessElement(SingleValueElement):
  """Path element representing access to the index of array."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a index access: ' + path_element)
    self._element, key = path_element.split('[')
    self._getter = _cpp_getter_name(self._element)
    self._key = key[:-1]

  def __eq__(self, other: SingleValueElement) -> bool:
    return isinstance(
        other, _IndexAccessElement) and self._element == other._element and (
            self._key == other._key)

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    return f'{self._element}[{self._key}]'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    if _parse_multi_value_element(path_element):
      return False
    return re.match(r'.*\[\d+\]$', path_element) is not None

  def access(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}({self._key})'

  def can_continue_on_miss(self, *, is_mutable: bool) -> bool:
    """Return True if access can move further on missed value."""
    del is_mutable  # unused
    return False

  def set_value_access(self, var_name: str, value: str) -> str:
    return f'{var_name}.set_{self._getter}({self._key}, {value})'

  def mutable_access(self, var_name: str) -> str:
    return f'{var_name}.mutable_{self._getter}()->at({self._key})'

  def has_access(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}().size() > {self._key}'

  def access_cost(self) -> float:
    return 0.5

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root.Child(table.ArrayAccess(self._element, int(self._key)))

  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return root.Column(table.ArrayAccess(self._element, int(self._key)))


class _MapAccessElement(SingleValueElement):
  """Path element representing access to the key in a map."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a map access: ' + path_element)
    m = re.match(r'(\w+)\[(.+)\]', path_element)
    assert m is not None
    self._element = m.groups()[0]  # type: str  # fixing pytype  # pytype: disable=annotation-type-mismatch
    key = m.groups()[1]
    self._getter = _cpp_getter_name(self._element)
    if key == '*':
      self._is_wildcard = True
      self._table_path_key = '%s'  # name will be format string
      self._key = _DYNAMIC_FEATURE_KEY
    else:
      self._is_wildcard = False
      self._table_path_key = key[1:-1]  # remove quotes
      self._key = '"%s"' % self._table_path_key  # update quotes

  def __eq__(self, other: SingleValueElement) -> bool:
    return isinstance(
        other, _MapAccessElement) and self._element == other._element and (
            self._key == other._key and self._is_wildcard == other._is_wildcard)

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    star = '*'
    return f'{self._element}[{star if self._is_wildcard else self._key}]'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    if _parse_multi_value_element(path_element):
      return False
    return (re.match(r'.*\[".+"\]$', path_element) is not None or
            re.match(r".*\['.+'\]$", path_element) is not None or
            re.match(r'.*\[\*\]$', path_element) is not None)

  @property
  def is_wildcard(self):
    return self._is_wildcard

  def can_continue_on_miss(self, *, is_mutable: bool) -> bool:
    return is_mutable  # We continue only on mutable.

  def access(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}().at({self._key})'

  def set_value_access(self, var_name: str, value: str) -> str:
    return f'(*{var_name}.mutable_{self._getter}())[{self._key}] = {value}'

  def mutable_access(self, var_name: str) -> str:
    return f'(*{var_name}.mutable_{self._getter}())[{self._key}]'

  def has_access(self, var_name: str) -> str:
    return f'{var_name}.{self._getter}().count({self._key}) > 0'

  def access_cost(self) -> float:
    return 22

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root.Child(table.MapAccess(self._element, self._table_path_key))

  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return root.Column(table.MapAccess(self._element, self._table_path_key))


def _maybe_unwrap_size(path_element: str) -> Optional[str]:
  """Remove count() from size protopath. Returns None otherwise."""
  m = re.match(r'count\((.*)\)$', path_element)
  return None if m is None else m.group(1)


class _SizeElement(SingleValueElement):
  """Path element representing access for size of the repeated field."""

  def __init__(self, path_element: str):
    if not self.is_this_type(path_element):
      raise ValueError('Not a size access: ' + path_element)
    multi_path_element = _maybe_unwrap_size(path_element)
    assert multi_path_element is not None
    multi_element = _parse_multi_value_element(multi_path_element)
    if multi_element is None:
      raise ValueError('Not a size access: ' + path_element)
    self._multi_element = multi_element

  def __eq__(self, other: SingleValueElement) -> bool:
    return isinstance(
        other, _SizeElement) and self._multi_element == other._multi_element

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    return f'count({self._multi_element.protopath_element()})'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return _maybe_unwrap_size(path_element) is not None

  def access(self, var_name: str) -> str:
    return f'{var_name}{self._multi_element.access_for_size}'

  def set_value_access(self, var_name: str, value: str) -> str:
    return self._multi_element.resize(var_name, value)

  def mutable_access(self, var_name: str) -> str:
    raise NotImplementedError(
        'mutable_access is not possible for SizeElement, use set_value_access.')

  def can_continue_on_miss(self, *, is_mutable: bool) -> bool:
    del is_mutable  # unused
    return True  # size is never missed

  def has_access(self, var_name: str) -> str:
    return 'true'  # size is never missed

  def access_cost(self) -> float:
    return 0.4

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    raise NotImplementedError('Size must be at the end')

  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return self._multi_element.size_column_path(root)


class _ExtensionSingleElement(SingleValueElement):
  """Path element representing proto extension access."""

  def __init__(self, path_element: str, is_final_access: bool):
    if not self.is_this_type(path_element):
      raise ValueError('Not an extension: ' + path_element)
    self._extension_name = path_element[len('Ext::'):]
    self._extension_identifier = self._extension_name.replace('.', '::')
    self._is_final_access = is_final_access

  def __eq__(self, other: SingleValueElement) -> bool:
    return isinstance(other, _ExtensionSingleElement) and (
        self._extension_name == other._extension_name and
        self._extension_identifier == other._extension_identifier and
        self._is_final_access == other._is_final_access)

  def protopath_element(self) -> str:
    """Returns canonical protopath element used for the creation."""
    return f'Ext::{self._extension_name}'

  @classmethod
  def is_this_type(cls, path_element: str) -> bool:
    return path_element.startswith('Ext::')

  def access(self, var_name: str) -> str:
    return f'{var_name}.GetExtension(::{self._extension_identifier})'

  def set_value_access(self, var_name: str, value: str) -> str:
    return f'{var_name}.SetExtension(::{self._extension_identifier}, {value})'

  def mutable_access(self, var_name: str) -> str:
    return f'*{var_name}.MutableExtension(::{self._extension_identifier})'

  def can_continue_on_miss(self, *, is_mutable: bool) -> bool:
    return is_mutable or not self._is_final_access

  def has_access(self, var_name: str) -> str:
    return f'{var_name}.HasExtension(::{self._extension_identifier})'

  def access_cost(self) -> float:
    return 2.0

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    return root.Child(table.ProtoExtensionAccess(self._extension_name))

  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    return root.Column(table.ProtoExtensionAccess(self._extension_name))


def _single_value_element(path_element: str,
                          is_final_access: bool = False) -> SingleValueElement:
  """Returns one of the implementation for single value element.

  Args:
    path_element: part of the protopath for single value access.
    is_final_access: whenever it is access to the final element in protopath.
      Some implementations may decide to avoid verifying presence for
      intermediate accesses for performance reasons.

  Returns:
    Parsed single value protopath element.
  """
  if _ExtensionSingleElement.is_this_type(path_element):
    return _ExtensionSingleElement(
        path_element, is_final_access=is_final_access)
  if _parse_multi_value_element(path_element) or '@' in path_element:
    raise ValueError('Not a single value: ' + path_element)
  if _IndexAccessElement.is_this_type(path_element):
    return _IndexAccessElement(path_element)
  if _MapAccessElement.is_this_type(path_element):
    return _MapAccessElement(path_element)
  if _SizeElement.is_this_type(path_element):
    return _SizeElement(path_element)
  if _DereferenceAccess.is_this_type(path_element):
    return _DereferenceAccess(path_element)
  if _AddressOfAccess.is_this_type(path_element):
    return _AddressOfAccess(path_element)
  if _StructFieldAccess.is_this_type(path_element):
    return _StructFieldAccess(path_element)
  if _RegularElement.is_this_type(path_element):
    return _RegularElement(path_element)
  raise ValueError('Unrecognized protopath element: ' + path_element)


class _SingleValueElementsList:
  """Path elements representing series of single value accesses."""

  def __init__(self, regular_elements: List[SingleValueElement]):
    self._elements = regular_elements

  def without_last_element(self) -> '_SingleValueElementsList':
    if self.is_empty:
      raise ValueError('without_last_elementis not supported for empty list.')
    return _SingleValueElementsList(self._elements[:-1])

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    res = root
    for sv in self._elements:
      res = sv.child_table_path(res)
    return res

  def child_column_path(self, root: table.TablePath) -> table.ColumnPath:
    if self.is_empty:
      raise ValueError('Child column is not supported for empty list.')
    res = root
    for sv in self._elements[:-1]:
      res = sv.child_table_path(res)
    return self._elements[-1].child_column_path(res)

  def __getitem__(self, idx: int) -> SingleValueElement:
    return self._elements[idx]

  def __len__(self) -> int:
    return len(self._elements)

  @property
  def is_empty(self) -> bool:
    return not self._elements

  def access_for_type(self, var_name: str) -> str:
    result = var_name
    for el in self._elements:
      result = el.access(result)
    return result

  def set_path_to_field(self,
                        tmp_prefix: str,
                        input_name: str,
                        output_name: str,
                        missing_action: str,
                        is_mutable: bool = False,
                        force_missing_check: bool = False) -> str:
    """Returns c++ code setting field to provided output_name.

    Output variable will be defined with decltype(auto), so life time
    could be limited to the input variable.
    Temporary variables could be created and they will stay in the scope.

    Args:
      tmp_prefix: prefix for the names of temporary variables.
      input_name: name of the input variable
      output_name: name of the variable to put result to.
      missing_action: c++ code need to be run on missed value, e.g., 'continue'
        or 'return result'. Final semicolon will be added.
      is_mutable: whenever `output_name` variable need to be mutable.
      force_missing_check: whenever presence should always be checked.

    Returns:
      C++ code
    """
    if self.is_empty:
      raise ValueError('Do not move variable on empty list')
    body = ''
    last_value = input_name
    const = 'const ' if not is_mutable else ''
    for i, element in enumerate(self._elements):
      if i + 1 < len(self._elements):
        next_value = '%s_%d' % (tmp_prefix, i)
      else:
        next_value = output_name
      if force_missing_check or not element.can_continue_on_miss(
          is_mutable=is_mutable):
        has_access = element.has_access(last_value)
        body += (f'\n  if (!({has_access})) {{ ' + f'{missing_action}; }}\n')
      last_value_access = (
          element.mutable_access(last_value)
          if is_mutable
          else element.access(last_value)
      )
      body += f"""
  {const}auto& {next_value} = {last_value_access};"""
      last_value = next_value

    return body


class _SingleMultiElemPath:
  """Represents path to the next range slice split.

  It is either the first or intermediate range in the form:
  a/b/c/d[:] or a/b[5]/c/d[:], i. e. a few accesses and range slice at the end.
  """

  def __init__(self, single_value_list: _SingleValueElementsList,
               multi_elem: MultipleValueElement):
    """Constructs from possibly empty single value prefix and range slice."""
    self._single_value_list = single_value_list
    self._multi_elem = multi_elem

  def child_table_path(self, root: table.TablePath) -> table.TablePath:
    res = self._single_value_list.child_table_path(root)
    return self._multi_elem.child_table_path(res)

  def size_column_path(self, root: table.TablePath) -> table.ColumnPath:
    res = self._single_value_list.child_table_path(root)
    return self._multi_elem.size_column_path(res)

  @property
  def single_value_list(self) -> List[SingleValueElement]:
    return list(self._single_value_list)

  @property
  def multi_element(self) -> MultipleValueElement:
    return self._multi_elem

  @property
  def support_mutable(self) -> bool:
    return self._multi_elem.support_mutable

  def access_for_type(self, var_name) -> str:
    return self._multi_elem.access_for_type(
        self._single_value_list.access_for_type(var_name))

  def gen_loop_size(self, size_var: str, input_name: str) -> str:
    """Returns code to reach the repeated field and put its size to size_var."""
    body = ''
    if self._single_value_list.is_empty:
      last_value = input_name
    else:
      last_value = size_var + '_last'
      body += self._single_value_list.set_path_to_field(
          tmp_prefix=size_var + '_tmp',
          input_name=input_name,
          output_name=last_value,
          missing_action='return 0')  # we are inside of lambda returning size

    size_path = self._multi_elem.access_for_size
    return (f'size_t {size_var} = [&]() {{ '
            f'{body}\nreturn {last_value}{size_path}; }}();')

  def open_loop(self,
                loop_var: str,
                input_name: str,
                is_mutable: bool = False) -> str:
    """Returns code to reach the repeated field and iterate over it.

    It is assumed that generated code will be located inside of the loop and
    `continue` statement will be used on missed value.

    Args:
      loop_var: name of the variable to use for the loop
      input_name: name of the input variable
      is_mutable: whenever `loop_var` variable need to be mutable.
    """
    body = ''
    if self._single_value_list.is_empty:
      last_value = input_name
    else:
      last_value = loop_var + '_last'
      body += self._single_value_list.set_path_to_field(
          tmp_prefix=loop_var + '_tmp',
          input_name=input_name,
          output_name=last_value,
          missing_action='continue',  # we assume that we already in the loop
          is_mutable=is_mutable,
          # We always check presence in mutable case before the last loop.
          # That way we avoid creation of unnecessary empty messages.
          force_missing_check=is_mutable)

    return body + '\n' + self._multi_elem.open_loop(
        loop_var, last_value, is_mutable=is_mutable)


_DEFAULT_ARRAY_GEN = array_generator.create_generator('DenseArray')


def _assign_item_size(input_name: str, multi_elems: List[_SingleMultiElemPath],
                      item_size_name: str) -> Tuple[List[str], str]:
  """Assigns size of the last repeated field to item_size_name.

  Args:
    input_name: name of the input variable
    multi_elems: list of elements corresponded to repeated fields
    item_size_name: name of the variable to assign size to

  Returns:
    Tuple with code for opening loops and loop body assigning size of
    the last repeated field to item_size_name.
  """
  loops = []
  if len(multi_elems) > 1:
    # _SingleMultiElemPath.open_loop expects be inside of the loop.
    loops.append('for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {')
  last_value = input_name
  for i, multi_elem in enumerate(multi_elems[:-1]):
    loop_var = 'value_%d' % i
    loops.append(multi_elem.open_loop(loop_var, last_value))
    last_value = loop_var

  loop_body = multi_elems[-1].gen_loop_size(item_size_name, last_value)
  return (loops, loop_body)


def _total_size_lambda(multi_elems: List[_SingleMultiElemPath],
                       capture_all: bool) -> str:
  """Returns lambda for the total size of the nested repeated fields."""
  if not multi_elems:
    return _single_input_lambda('return 1;')
  loops, loop_body = _assign_item_size('input', multi_elems, 'final_size')
  loop_body += '\ntotal_size += final_size;'

  body = """size_t total_size = 0;
{loops_start}
{loop_body}
{loops_end}
return total_size;""".format(
    loops_start=''.join(loops), loop_body=loop_body, loops_end='}' * len(loops))

  return _single_input_lambda(body, capture_all=capture_all)


def _parse_protopath_impl(
    protopath: str
) -> Tuple[List[_SingleMultiElemPath], _SingleValueElementsList, bool]:
  """Parse and split protopath into sequences of single values."""
  if protopath.startswith('//'):
    raise ValueError('double-slash is not supported: ' + protopath)
  if protopath.startswith('/'):
    protopath = protopath[1:]  # Skip the leading slash.

  # Concatenate attribute fields like `@attr` to the previous element.
  elements = protopath.replace('/@', '@').split('/')
  for el in elements:
    if not el:
      raise ValueError('empty element in the path: ' + protopath)
  for el in elements[:-1]:
    if _SizeElement.is_this_type(el):
      raise ValueError('count is only allowed at the end: ' + protopath)

  prev_range = 0
  multi_elems = []
  for idx, multi_candidate in enumerate(elements):
    multi_elem = _parse_multi_value_element(multi_candidate)
    if multi_elem:
      multi_elems.append(
          _SingleMultiElemPath(
              _SingleValueElementsList([
                  _single_value_element(el) for el in elements[prev_range:idx]
              ]), multi_elem))
      prev_range = idx + 1

  last_path_elements = elements[prev_range:]
  if not last_path_elements:
    last_path = _SingleValueElementsList([])
  else:
    last_path = _SingleValueElementsList(
        [_single_value_element(el) for el in elements[prev_range:-1]] +
        [_single_value_element(elements[-1], is_final_access=True)])

  return multi_elems, last_path, _SizeElement.is_this_type(elements[-1])


def _count_wildcards(elements: _SingleValueElementsList) -> int:
  return sum(1 if e.is_wildcard else 0 for e in elements)


class ProtopathAccessor(accessors.Accessor):
  """Accessor with additional protopath information."""

  def __init__(self,
               lambda_str: str,
               includes: List[cpp.Include],
               default_name: Optional[str] = None,
               *,
               protopath: str,
               cpp_type: Optional[str],
               default_value_cpp: Optional[str] = None):
    """Constructs protopath accessor.

    Args:
      lambda_str: c++ code for the lambda. See base class for more details.
      includes: list of cpp.Include with required header files.
      default_name: default name for this accessor. Used as a name if not
        specified by AccessorsList. If None, name must be specified explicitly
        in AccessorsList.
      protopath: original protopath used for this accessor
      cpp_type: cpp type to use for single element. If None type is
        deducted from protobuf cpp type.
      default_value_cpp: C++ value to use as default.
        Value must be implicitly convertible to cpp_type.
        Result type:
        * default_value_cpp is None: optional (or array)
        * default_value_cpp is not None: non optional (or array)
    """
    super().__init__(lambda_str, includes, default_name)
    self.protopath = protopath
    self.cpp_type = cpp_type
    self.default_value_cpp = default_value_cpp

  def __eq__(self, other) -> bool:
    return isinstance(other, ProtopathAccessor) and (other.protopath
                                                     == self.protopath)


class Protopath:
  """Represents protopath of elements."""

  def __init__(self,
               multi_elems: List[_SingleMultiElemPath],
               last_path: _SingleValueElementsList,
               is_size: bool = False,
               is_wildcard: bool = False,
               input_type: str = 'auto',
               *,
               protopath: str):
    """Constructs protopath from parsed path elements.

    Args:
      multi_elems: list of paths up to the last repeated field If empty, single
        value element is being accessed.
      last_path: access after the last repeated If `last_path.is_empty`,
        repeated primitive value is being accessed.
      is_size: whenever the last access is `count([:])`
      is_wildcard: whenever one of the access is `field_name[*]`
      input_type: fully qualified C++ input type
      protopath: protopath used for the creation
    """
    self._multi_elems = multi_elems
    self._last_path = last_path
    self._is_size = is_size
    self._is_wildcard = is_wildcard
    self._input_type = input_type
    self._protopath = protopath
    if not self._multi_elems and self._last_path.is_empty:
      raise ValueError('Empty protopath is not supported.')

  @property
  def is_size(self) -> bool:
    """Returns true iff the last access is `count([:])`."""
    return self._is_size

  @property
  def is_single_value(self) -> bool:
    """Returns true iff the result is single value."""
    return not self._multi_elems

  @property
  def protopath(self) -> str:
    """Returns original protopath string."""
    return self._protopath

  @property
  def multi_elems(
      self) -> List[Tuple[List[SingleValueElement], MultipleValueElement]]:
    return [(multi_elem.single_value_list, multi_elem.multi_element)
            for multi_elem in self._multi_elems]

  @property
  def last_path_list(self) -> List[SingleValueElement]:
    return list(self._last_path)

  @property
  def default_name(self) -> str:
    """Name for `accessor`. Will be used if not specified explicitly."""
    t = table.TablePath()
    for me in self._multi_elems:
      t = me.child_table_path(t)
    if self._last_path.is_empty:
      return str(t)
    return str(self._last_path.child_column_path(t))

  def accessor(self,
               array_gen: Optional[
                   array_generator.ArrayBuilderGenerator] = _DEFAULT_ARRAY_GEN,
               cpp_type: Optional[str] = None) -> ProtopathAccessor:
    """Returns accessor for the elements.

    Args:
      array_gen: generator to use for multivalue protopaths Allowed to be none
        for single value accessors.
      cpp_type: optional cpp type to use for single element If None type is
        deducted from protobuf cpp type.
    """
    if not cpp_type:
      cpp_type = '::arolla::proto::arolla_size_t' if self._is_size else None
    if not self._multi_elems:
      if self._is_size:
        return self._size_shape_accessor(array_gen)
      else:
        return self._optional_accessor(cpp_type)
    else:
      if array_gen is None:
        raise ValueError('Array generator is required for multivalue accessors')
      return self._array_accessor(array_gen, cpp_type)

  def scalar_accessor_with_default_value(
      self, *, cpp_type: str,
      default_value_cpp: str) -> ProtopathAccessor:
    """Returns accessor for single value assigned to default if missing."""
    assert not self._is_size
    assert not self._multi_elems
    body = f'\n*output = {default_value_cpp};\n'
    last_field_setter = self._last_path.set_path_to_field(
        tmp_prefix='val',
        input_name='input',
        output_name='final_result',
        missing_action='return')
    body += f"""
        {last_field_setter}
        *output = final_result;
    """
    return ProtopathAccessor(
        self._wrap_lambda(body, output_type=cpp_type),
        _MANDATORY_INCLUDES,
        self.default_name,
        protopath=self._protopath,
        cpp_type=cpp_type,
        default_value_cpp=default_value_cpp)

  def mutable_accessor(self,
                       *,
                       array_gen: Optional[
                           array_generator.ArrayBuilderGenerator] = None,
                       cpp_type: Optional[str] = None) -> ProtopathAccessor:
    """Returns accessor for the modifying elements.

    The returned accessor is a meta constexpr factory function.
    It need to be called with std::decay<Input>()
    (or std::type_identity<Input>() in C++20) argument to get non
    polymorphic lambda function. Returned lambda can be analyzed with
    ::arolla::meta::function_traits to gather types information.

    Lambda usage example:
    constexpr auto factory_fn = <generated lambda code here>;
    constexpr auto mutation_fn = factory_fn(std::decay<MyProto>());
    // TODO: create a traits for the next using
    using result_t = std::decay_t<::arolla::meta::head_t<
        typename ::arolla::meta::function_traits<
            decltype(mutation_fn)>::arg_types>>;
    result_t result = ComputeResult(...);
    MyProto my_proto;
    mutation_fn(result, &my_proto);

    Args:
      array_gen: generator to use for multivalue protopaths Allowed to be none
        for single value accessors.
      cpp_type: optional cpp type to use for single element If None type is
        deducted from protobuf cpp type.
    """
    if not cpp_type and self._is_size:
      if array_gen is None:
        raise ValueError('array_gen is required for size accessors.')
      cpp_type = (
          '::arolla::proto::arolla_size_t'
          if self._multi_elems
          else array_gen.shape_type()
      )
    if self._last_path.is_empty:
      raise ValueError(
          'mutable accessors not supported for repeated primitive fields.')
    if self._is_wildcard:
      raise ValueError('Wildcard mutable accessors is not supported.')
    if self._multi_elems:
      if array_gen is None:
        raise ValueError(
            'array_gen is required for repeated mutable accessors.')
      return self._mutable_array_accessor(array_gen, cpp_type)
    else:
      return self._mutable_optional_accessor(cpp_type)

  def _wrap_lambda(self, body: str, output_type: Optional[str] = None) -> str:
    """Wrap body to the appropriate lambda."""
    if self._is_wildcard:
      if self._multi_elems:
        return _dynamic_input_lambda_with_factory(
            body, input_type=self._input_type)
      else:
        return _dynamic_input_lambda(
            body, input_type=self._input_type, output_type=output_type)
    else:
      if self._multi_elems:
        return _input_lambda_with_factory(body, input_type=self._input_type)
      else:
        return _single_input_lambda(
            body, input_type=self._input_type, output_type=output_type)

  def _access_for_type(self, var_name: str) -> str:
    result = var_name
    for r in self._multi_elems:
      result = r.access_for_type(result)
    return self._last_path.access_for_type(result)

  def _value_type_definition(self,
                             var_name: str = 'input',
                             *,
                             cpp_type: Optional[str] = None,
                             gen_proto_value_type: bool = False) -> str:
    """Returns proto_value_type and value_type definitions."""
    proto_value_type = ('\nusing proto_value_type = '
                        'std::decay_t<decltype({access_for_type})>;').format(
                            access_for_type=self._access_for_type(var_name))
    if cpp_type:
      return (proto_value_type if gen_proto_value_type else '') + """
          using value_type = %s;
          """ % cpp_type
    else:
      return proto_value_type + """
          using value_type = ::arolla::proto::arolla_single_value_t<
              proto_value_type>;
          """

  def _size_shape_accessor(
      self,
      array_gen: array_generator.ArrayBuilderGenerator) -> ProtopathAccessor:
    """Returns accessor for sizes of top level repeated field."""
    assert self._is_size
    empty_shape = array_gen.create_shape('0')
    body = self._last_path.set_path_to_field(
        tmp_prefix='val',
        input_name='input',
        output_name='final_result',
        missing_action=f'return {empty_shape}')
    shape = array_gen.create_shape('static_cast<int64_t>(final_result)')
    body += f'\nreturn {shape};'
    return ProtopathAccessor(
        self._wrap_lambda(body),
        _MANDATORY_INCLUDES + array_gen.required_includes(),
        self.default_name,
        protopath=self._protopath,
        cpp_type=None)

  def _optional_accessor(self, cpp_type: Optional[str]) -> ProtopathAccessor:
    """Returns accessor for single value."""
    assert not self._is_size
    value_type = (
        cpp_type if cpp_type else f'decltype({self._access_for_type("input")})')
    output_type = f'::arolla::proto::arolla_optional_value_t<{value_type}>'
    body = '\noutput->present = false;\n'
    last_field_setter = self._last_path.set_path_to_field(
        tmp_prefix='val',
        input_name='input',
        output_name='final_result',
        missing_action='return')
    body += f"""
        {last_field_setter}
        output->present = true;
        output->value = final_result;
    """
    return ProtopathAccessor(
        self._wrap_lambda(body, output_type=output_type),
        _MANDATORY_INCLUDES,
        self.default_name,
        protopath=self._protopath,
        cpp_type=cpp_type)

  def _mutable_optional_accessor(self,
                                 cpp_type: Optional[str]) -> ProtopathAccessor:
    """Returns accessor for modifying single value."""
    pre_last_path = self._last_path.without_last_element()
    if pre_last_path.is_empty:
      pre_last_field_setter = 'auto& final_mutable_field = *output_ptr;'
    else:
      pre_last_field_setter = pre_last_path.set_path_to_field(
          tmp_prefix='val',
          input_name='(*output_ptr)',
          output_name='final_mutable_field',
          missing_action='return',
          is_mutable=True)
    final_element = self._last_path[-1]
    has_access = final_element.has_access('final_mutable_field')
    can_continue_on_miss = final_element.can_continue_on_miss(is_mutable=True)
    missing_condition = ('' if can_continue_on_miss else
                         f'if (!({has_access})) {{ return; }}')
    body = """
    using output_type = typename decltype(output_type_meta_fn)::type;
    {value_type_definition}
    using input_type = ::arolla::proto::arolla_optional_value_t<value_type>;
    return [](const input_type& input, output_type* output_ptr) {{
        if (!input.present) {{ return; }}
        {pre_last_field_setter}
        {missing_condition}
        {final_set_value};
    }};""".format(
        value_type_definition=self._value_type_definition(
            var_name='std::declval<output_type>()',
            cpp_type=cpp_type,
            gen_proto_value_type=True,
        ),
        pre_last_field_setter=pre_last_field_setter,
        missing_condition=missing_condition,
        final_set_value=final_element.set_value_access(
            'final_mutable_field', 'proto_value_type(input.value)'
        ),
    )
    return ProtopathAccessor(
        _mutable_lambda(body),
        _MANDATORY_INCLUDES,
        self.default_name,
        protopath=self._protopath,
        cpp_type=cpp_type)

  def _array_accessor(self, array_gen: array_generator.ArrayBuilderGenerator,
                      cpp_type: Optional[str]) -> ProtopathAccessor:
    """Returns accessor for array value."""
    loops = ['for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {']
    last_value = 'input'
    for i, multi_elem in enumerate(self._multi_elems):
      loop_var = 'value_%d' % i
      loops.append(multi_elem.open_loop(loop_var, last_value))
      last_value = loop_var
    loop_body = ''
    if not self._last_path.is_empty:
      missing_action = (
          # no missing values in size accessor is expected
          array_gen.push_back_item('0')
          if self._is_size else array_gen.push_back_empty_item()
      ) + '\ncontinue'  # we assume that we are in the loop
      final_item = 'final_item'
      loop_body += self._last_path.set_path_to_field(
          tmp_prefix=last_value + '_tmp',
          input_name=last_value,
          output_name=final_item,
          missing_action=missing_action)
      last_value = final_item
    loop_body += '\n' + array_gen.push_back_item(last_value)

    body = 'size_t total_size = {total_size_lambda}(input);\n'.format(
        total_size_lambda=_total_size_lambda(
            self._multi_elems, capture_all=self._is_wildcard))
    body += array_gen.define_array(
        'value_type',
        'total_size',
        _FACTORY_ARG_NAME_KEY,
        always_present=self._is_size)
    body += """
  {loops_start}
    {loop_body}
  {loops_end}
  """.format(
      loops_start=''.join(loops),
      loop_body=loop_body,
      loops_end='}' * len(loops))
    body += array_gen.return_array()

    return ProtopathAccessor(
        self._wrap_lambda(
            self._value_type_definition(cpp_type=cpp_type) + body),
        _MANDATORY_INCLUDES + array_gen.required_includes(),
        self.default_name,
        protopath=self._protopath,
        cpp_type=cpp_type)

  def _mutable_array_accessor(self,
                              array_gen: array_generator.ArrayBuilderGenerator,
                              cpp_type: Optional[str]) -> ProtopathAccessor:
    """Returns accessor for modifying repeated values."""
    loops = ['for (int _fake_var = 0; _fake_var != 1; ++_fake_var) {']
    last_value = '(*output_ptr)'
    for i, multi_elem in enumerate(self._multi_elems):
      loop_var = 'value_%d' % i
      loops.append(multi_elem.open_loop(loop_var, last_value, is_mutable=True))
      last_value = loop_var
    loop_body = 'if (input.present(id)) {'
    if self._last_path.is_empty:
      raise ValueError(
          f'Last access must be not repeated for mutable accessor: {self.default_name}'
      )
    pre_last_path = self._last_path.without_last_element()
    missing_action = '++id; continue'  # we assume that we are in the loop
    if not pre_last_path.is_empty:
      final_item = 'final_item'
      loop_body += pre_last_path.set_path_to_field(
          tmp_prefix=last_value + '_tmp',
          input_name=last_value,
          output_name=final_item,
          missing_action=missing_action,
          is_mutable=True)
      last_value = final_item
    final_element = self._last_path[-1]
    has_access = final_element.has_access(last_value)
    can_continue_on_miss = final_element.can_continue_on_miss(is_mutable=True)
    missing_condition = ('' if can_continue_on_miss else
                         f'if (!({has_access})) {{ {missing_action}; }}')
    final_set_value = final_element.set_value_access(
        last_value, 'proto_value_type(input.values[id])')
    loop_body += f"""
          {missing_condition}
          {final_set_value};
        }}
        ++id;
    """

    body = """
using output_type = typename decltype(output_type_meta_fn)::type;
{value_type_definition}
using input_type = ::arolla::DenseArray<value_type>;
return [](const input_type& input, output_type* output_ptr) -> absl::Status {{
    """.format(
        value_type_definition=self._value_type_definition(
            var_name='std::declval<output_type>()',
            cpp_type=cpp_type,
            gen_proto_value_type=True,
        )
    )
    body += 'size_t total_size = {total_size_lambda}(*output_ptr);\n'.format(
        total_size_lambda=_total_size_lambda(
            self._multi_elems, capture_all=False))
    body += f"""
    if (total_size != input.size()) {{
      return absl::FailedPreconditionError(absl::StrFormat(
        "unexpected array size for " R"raw_name({self.default_name}:)raw_name"
        " proto size %d vs array size %d", total_size, input.size()));
    }}
    """
    body += """
  size_t id = 0;
  {loops_start}
    {loop_body}
  {loops_end}
  return absl::OkStatus();
  }};""".format(
      loops_start=''.join(loops),
      loop_body=loop_body,
      loops_end='}' * len(loops))

    return ProtopathAccessor(
        _mutable_lambda(body),
        _MANDATORY_INCLUDES + array_gen.required_includes(),
        self.default_name,
        protopath=self._protopath,
        cpp_type=cpp_type)

  @classmethod
  def parse(cls, protopath: str, input_type: str = 'auto') -> 'Protopath':
    """Constructs Proptopath by parsing XPath-like string.

    Supported XPath operators:
      /   Child operator: selects immediate child of the left-side message.
          Child must not be a repeated field.
      [:]: selects all elements from provided slice (array-like type will be
      returned)
      [i]: selects ith element from repeated field
      ["key"]: selects element with "key" from map<string, T> field
      [:]/@key: selects all sorted keys in the map
      [:]/@value: selects all values sorted by keys in the map

    Unsupported operators (but planned to be supported):
      []  Slice:  Selects a slice of elements or a single element.

    Args:
      protopath: protopath string
      input_type: input type for the accessors

    Returns:
      Protopath

    Examples:
      message Root {
        optional int32 x = 1;
        repeated int32 ys = 2;
        message Inner {
          optional int32 a = 1;
          repeated int32 as = 2;
        }
        optional Inner inner = 3;
        repeated Inner inners = 4;
      }
      "x" gives field `x`
          value is missed if x is missed from proto.
      "inner/a" gives field `a` inside of field `inner`
          value is missed if either `inner` or `a` is missed from proto.
      "ys[:]" gives full array with numbers from field `y`
      "inner/as[:]" gives full array with numbers from field `as` inside `inner`
      "inners[:]/as[:]" gives full array with numbers from field `as` inside
      `inners`
          numbers from all `inners` fields are concatenated
      "inners[:]/a" gives array with numbers from field `a` inside `inners`
          item in arrays is missed if `a` missed in the `inners` field
    """
    multi_elems, last_path, is_size = _parse_protopath_impl(protopath)
    wildcard_count = _count_wildcards(last_path) + sum(
        _count_wildcards(e.single_value_list) for e in multi_elems)  # pytype: disable=wrong-arg-types  # always-use-return-annotations
    if wildcard_count > 0:
      raise ValueError('Wildcards are not supported. Use parse_wildcard. ' +
                       protopath)
    return Protopath(
        multi_elems,
        last_path,
        is_size=is_size,
        input_type=input_type,
        protopath=protopath)

  @classmethod
  def parse_wildcard(cls,
                     protopath: str,
                     input_type: str = 'auto') -> 'Protopath':
    """Parses proptopath with a single map wildcard.

    E.g., `abc/map[*]`.

    Args:
      protopath: wildcard protopath. See Protopath.parse for syntax details.
        Must contain exactly one wildcard.
      input_type: input type for the accessors

    Returns:
      Protopath. `Protopath.accessor` will return special wildcard Accessor:
      * lambda will be with two arguments
          [](const auto& input, absl::string_view feature_key) { ... }
      * default_name will be format string and contain '%s'.
    """
    multi_elems, last_path, is_size = _parse_protopath_impl(protopath)
    wildcard_count = _count_wildcards(last_path) + sum(
        _count_wildcards(e.single_value_list) for e in multi_elems)  # pytype: disable=wrong-arg-types  # always-use-return-annotations
    if wildcard_count != 1:
      raise ValueError('Exactly one wildcard expected. ' + protopath)
    if is_size:
      raise ValueError('Size protopath is not supported with wildcards. ' +
                       protopath)
    return Protopath(
        multi_elems,
        last_path,
        is_wildcard=True,
        input_type=input_type,
        protopath=protopath)


def collect_extensions_per_containing_type(
    file_descriptors: Iterable[descriptor.FileDescriptor]
) -> Dict[str, List[descriptor.FieldDescriptor]]:
  """Collect all extensions defined in the given list of FileDescriptors.

  Args:
    file_descriptors: list of file descriptors

  Returns:
    dictionary from a full name of the containing type to the extension
    field descriptors.
  """
  type2extensions = dict()
  for fdescr in file_descriptors:
    for extension in fdescr.extensions_by_name.values():
      type2extensions.setdefault(extension.containing_type.full_name,
                                 []).append(extension)
    _collect_extensions_from_messages(fdescr.message_types_by_name.values(),
                                      type2extensions)
  return type2extensions


def is_repeated_field(d: descriptor.FieldDescriptor) -> bool:
  """Returns True iff field is repeated."""
  return d.label == descriptor.FieldDescriptor.LABEL_REPEATED


def no_skip_fn(d: descriptor.FieldDescriptor) -> bool:
  """Always returning False function for skipping fields."""
  del d  # unused
  return False


def accessors_from_descriptor(
    pb_descriptor: descriptor.Descriptor,
    array_gen: Optional[array_generator.ArrayBuilderGenerator],
    *,
    accessor_input_type: str = 'auto',
    type2extensions: Optional[
        Dict[str, List[descriptor.FieldDescriptor]]
    ] = None,
    default_name_modifier_fn: Callable[[str], str] = lambda x: x,
    text_cpp_type: str = '::arolla::Text',
    skip_field_fn: Callable[[descriptor.FieldDescriptor], bool] = no_skip_fn,
    mutable: bool = False,
    protopath_prefix: Optional[str] = None,
) -> List[Tuple[str, ProtopathAccessor]]:
  """Returns sorted by name list of accessors to the proto fields.

  Args:
    pb_descriptor: descriptor of the root proto
    array_gen: array generator for repeated fields. If None, no repeated fields
      will be returned.
    accessor_input_type: fully qualified C++ class name for accessor input
    type2extensions: mapping from a full name of the message type to list of
      extensions extending it.
    default_name_modifier_fn: modifier applied to the full default name
    text_cpp_type: cpp type need to be used for `string` (but not bytes) fields
    skip_field_fn: when this function returning True the field will be skipped
    mutable: if True produces mutable accessors
    protopath_prefix: protopath prefix for all accessors
  """
  return sorted(
      _accessors_from_descriptor_impl(
          pb_descriptor,
          accessor_input_type=accessor_input_type,
          type2extensions=type2extensions or {},
          skip_field_fn=skip_field_fn,
          mutable=mutable,
          text_cpp_type=text_cpp_type,
          array_gen=array_gen,
          default_name_modifier_fn=default_name_modifier_fn,
          parent_path=protopath_prefix,
          skip_msg_types=set()))


def _collect_extensions_from_messages(
    message_descriptors: Iterable[descriptor.Descriptor],
    type2extensions: Dict[str, List[descriptor.FieldDescriptor]]):
  """Recursively traverse messages and update type2extension dict."""
  for descr in message_descriptors:
    _collect_extensions_from_messages(descr.nested_types, type2extensions)
    for extension in descr.extensions:
      type2extensions.setdefault(extension.containing_type.full_name,
                                 []).append(extension)


def _is_map_entry(field: descriptor.FieldDescriptor) -> bool:
  """Returns true iff field is map."""
  return (field.type == descriptor.FieldDescriptor.TYPE_MESSAGE and
          field.message_type.has_options and
          field.message_type.GetOptions().map_entry)


def _accessors_from_descriptor_impl(
    pb_descriptor: descriptor.Descriptor, *, accessor_input_type: str,
    type2extensions: Dict[str, List[descriptor.FieldDescriptor]],
    skip_field_fn: Callable[[descriptor.FieldDescriptor],
                            bool], mutable: bool, text_cpp_type: str,
    array_gen: Optional[array_generator.ArrayBuilderGenerator],
    default_name_modifier_fn: Callable[[str], str], parent_path: Optional[str],
    skip_msg_types: AbstractSet[str]) -> List[Tuple[str, ProtopathAccessor]]:
  """Returns list of named accessors for proto fields."""
  res = []
  fields_by_name = itertools.chain(
      pb_descriptor.fields, type2extensions.get(pb_descriptor.full_name, []))
  for field_descriptor in fields_by_name:
    if skip_field_fn(field_descriptor):
      continue
    name = field_descriptor.name
    if _is_map_entry(field_descriptor):
      continue
    is_repeated = is_repeated_field(field_descriptor)
    if is_repeated and array_gen is None:
      continue  # skip due to absence of array_gen
    if field_descriptor.is_extension:
      if is_repeated:
        continue  # repeated extensions are not populated yet
      path_el = table.ProtoExtensionAccess(field_descriptor.full_name)
    else:
      path_el = name + '[:]' if is_repeated else name
    path = path_el
    if parent_path:
      path = f'{parent_path}/{path}'
    ppath = Protopath.parse(path, input_type=accessor_input_type)
    need_add_size = is_repeated and (
        # mutation of primitive repeated fields is not supported
        not mutable or field_descriptor.message_type is not None)
    if need_add_size:
      assert array_gen is not None
      size_path = f'count({path_el})'
      if parent_path:
        size_path = f'{parent_path}/{size_path}'
      size_ppath = Protopath.parse(size_path, input_type=accessor_input_type)
      accessor = (
          size_ppath.mutable_accessor(array_gen=array_gen)
          if mutable else size_ppath.accessor(array_gen=array_gen))
      res.append((default_name_modifier_fn(size_ppath.default_name), accessor))
    if field_descriptor.message_type is not None:
      nested_pb_descriptor = field_descriptor.message_type
      msg_types = skip_msg_types | {pb_descriptor.full_name}
      if nested_pb_descriptor.full_name in msg_types:
        # Skip recursive submessages to avoid infinite recursion.
        continue
      res.extend(
          _accessors_from_descriptor_impl(
              nested_pb_descriptor,
              accessor_input_type=accessor_input_type,
              type2extensions=type2extensions,
              skip_field_fn=skip_field_fn,
              mutable=mutable,
              text_cpp_type=text_cpp_type,
              array_gen=array_gen,
              default_name_modifier_fn=default_name_modifier_fn,
              parent_path=path,
              skip_msg_types=msg_types))
      continue
    cpp_type = None
    if field_descriptor.type == descriptor.FieldDescriptor.TYPE_STRING:
      cpp_type = text_cpp_type
    accessor_name = default_name_modifier_fn(ppath.default_name)
    if mutable:
      if not is_repeated:
        accessor = ppath.mutable_accessor(
            array_gen=array_gen, cpp_type=cpp_type)
        res.append((accessor_name, accessor))
    else:
      accessor = ppath.accessor(array_gen, cpp_type=cpp_type)
      res.append((accessor_name, accessor))
  return res


def import_proto_class(full_name: str):
  """Imports a Python proto module, and returns a class from that module.

  Args:
    full_name: The fully qualified name of a proto message type, e.g.
      "my.package.my_proto_pb2.MyMessage"

  Returns:
    A google.protobuf.message.Message type.
  """
  if '_pb2.' not in full_name:
    raise ValueError(f'Expected {full_name} to contain "_pb2."')
  module_name, proto_name = full_name.rsplit('_pb2.', 1)
  module = importlib.import_module(f'{module_name}_pb2')
  proto = module
  for part in proto_name.split('.'):
    proto = getattr(proto, part)
  return proto
