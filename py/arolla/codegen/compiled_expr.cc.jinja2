{#- jinja2 file itself is *not* auto generated. -#}
// NOLINTBEGIN
// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Build target:
// {{ build_target }}

#include <cstddef>
#include <cstdint>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "absl//base/attributes.h"
#include "absl//base/no_destructor.h"
#include "absl//container/flat_hash_map.h"
#include "arolla/memory/frame.h"
#include "arolla/memory/optional_value.h"
#include "arolla/qexpr/eval_context.h"
#include "arolla/qexpr/evaluation_engine.h"
#include "arolla/qexpr/lifting.h"
#include "arolla/qexpr/operators.h"
#include "arolla/qexpr/qexpr_operator_signature.h"
#include "arolla/qtype/base_types.h"
#include "arolla/qtype/qtype_traits.h"
#include "arolla/qtype/qtype.h"
#include "arolla/qtype/typed_slot.h"
#include "arolla/qtype/typed_value.h"
#include "arolla/util/meta.h"
#include "arolla/util/status.h"
{%- for hdr in headers %}
#include "{{ hdr }}"
{%- endfor %}{# hdr #}

namespace {

using ::arolla::BoundExpr;
using ::arolla::BoundOperator;
using ::arolla::EvaluationContext;
using ::arolla::FindSlotsAndVerifyTypes;
using ::arolla::FrameLayout;
using ::arolla::FramePtr;
using ::arolla::InplaceCompiledExpr;
using ::arolla::QExprOperator;
using ::arolla::QTypePtr;
using ::arolla::TypedSlot;

}  // namespace

{%- for cpp_function_name, operator_data in operator_datas %}
{%- set operator_id = loop.index0 %}

namespace impl{{ operator_id }} {
namespace {

{#- it is faster to have local variables to avoid copying happen in CLIF -#}
{%- set inputs = operator_data.inputs -%}
{%- set side_outputs = operator_data.side_outputs -%}
{%- set input_id_to_name = operator_data.input_id_to_name -%}
{%- set input_names = inputs.keys()|sort -%}
{%- set assignments = operator_data.assignments %}

{#- generates c++ type of the requested assignment -#}
{%- macro lvalue_type(assignment_id) -%}
  {%- set lvalue = assignments[assignment_id].lvalue -%}
  {{lvalue.type_name}}
{%- endmacro %}

{%- macro lvalue_qtype(assignment_id) -%}
  {%- set lvalue = assignments[assignment_id].lvalue -%}
  {{lvalue.qtype_construction()}}
{%- endmacro %}

struct Offsets {
{%- if input_names %}
  size_t inputs[{{ input_names | length }}];
{%- endif -%}{#- input_names #}
{%- if side_outputs %}
  size_t named_outputs[{{ side_outputs | length }}];
{%- endif -%}{#- side_outputs #}
  size_t output;
};

class IoImpl {
 public:
  explicit IoImpl(const Offsets& offsets, FramePtr frame)
      : offsets_(offsets), frame_(frame) {}
{% if inputs %}
  template <class T>
  decltype(auto) GetInput(int64_t input_id) const {
    return frame_.Get(
        FrameLayout::Slot<T>::UnsafeSlotFromOffset(offsets_.inputs[input_id]));
  }
{% endif %}{#- inputs #}

{%- if side_outputs %}
  template <class T>
  T SetSideOutputSlot(
      int64_t export_id,
      const T& side_output) const {
    static_assert(
      !std::is_same_v<::arolla::strip_statusor_t<T>, ::arolla::TypedValue>,
      "TypedValue side outputs (e.g., Tuple) are not yet supported."
    );
    if (::arolla::IsOkStatus(side_output)) {
      frame_.Set(
          FrameLayout::Slot<::arolla::strip_statusor_t<T>>::UnsafeSlotFromOffset(
              offsets_.named_outputs[export_id]),
              ::arolla::UnStatus(side_output));
    }
    return side_output;
  }
{% endif %}{#- side_outputs #}
  const Offsets& offsets_;
  FramePtr frame_;
};

{%- include 'compiled_expr_impl.cc.jinja2' %}

class GenBoundOperator final : public BoundOperator {
 public:
{%-   set final_lvalue = assignments[operator_data.output_id].lvalue %}
{%-   set is_typed_value = final_lvalue.type_name == "::arolla::TypedValue" %}
  explicit GenBoundOperator(Offsets offsets, TypedSlot output_slot)
      : offsets_(offsets)
{%-   if is_typed_value %}
    , output_slot_(output_slot)
{%-   endif %}{#- is_typed_value #} {}

  void Run(EvaluationContext* ctx, FramePtr frame) const final {
    auto io = IoImpl(offsets_, frame);
    auto evaluator = GenEvaluator(ctx, io);
{%-   if final_lvalue.is_entire_expr_status_or %}
    auto output_or = evaluator.Eval();
    if (!output_or.ok()) {
      ctx->set_status(std::move(output_or).status());
      return;
    }
    auto get_output = [&]() { return std::move(output_or).value(); };
{%- else %}
    auto get_output = [&]() { return evaluator.Eval(); };
{%- endif %}{#- final_lvalue.is_entire_expr_status_or #}
{%- if is_typed_value %}
    absl::Status status = get_output().CopyToSlot(output_slot_, frame);
    if (!status.ok()) {
      ctx->set_status(std::move(status));
      return;
    }
{%- else %}
    auto* output = frame.GetMutable(
        FrameLayout::Slot<{{ final_lvalue.type_name }}>::UnsafeSlotFromOffset(
            offsets_.output));
    *output = get_output();
{%- endif %}{#- is_typed_value #}
  }

 private:
  Offsets offsets_;
{%- if is_typed_value %}
  TypedSlot output_slot_;
{%- endif %}{#- is_typed_value #}
};

class GenBoundExpr final : public BoundExpr {
 public:
  GenBoundExpr(  //
      GenBoundOperator op,
      absl::flat_hash_map<std::string, TypedSlot> input_slots,
      TypedSlot output_slot,
      absl::flat_hash_map<std::string, TypedSlot> named_output_slots)
      : BoundExpr(std::move(input_slots), output_slot,
                  std::move(named_output_slots)),
        op_(std::move(op)) {}

  void InitializeLiterals(EvaluationContext*, FramePtr) const final {}

  void Execute(EvaluationContext* ctx, FramePtr frame) const final {
    op_.Run(ctx, frame);
  }

 private:
  GenBoundOperator op_;
};

absl::NoDestructor<std::vector<std::pair<std::string, QTypePtr>>>
    kNamedInputTypesInOrder(std::vector<std::pair<std::string, QTypePtr>>{
{%- for input_name in input_names %}
        {"{{ input_name }}", {{ lvalue_qtype(inputs[input_name]) }}},
{%- endfor %}{# input_name #}
    });

{%- if side_outputs %}
absl::NoDestructor<std::vector<std::pair<std::string, QTypePtr>>>
kNamedOutputTypesInOrder(std::vector<std::pair<std::string, QTypePtr>>{
{%- for output_name, lvalue_id in side_outputs %}
    {"{{ output_name }}", {{ lvalue_qtype(lvalue_id) }}},
{%- endfor %}{# output_name #}
});
{% endif %}{#- side_outputs #}

absl::NoDestructor<std::vector<QTypePtr>>
kInputTypesInOrder([]() {
  std::vector<QTypePtr> types;
  for (const auto& [_, type] : *kNamedInputTypesInOrder) {
    types.push_back(type);
  }
  return types;
}());

class GenOperator : public QExprOperator {
 public:
  explicit GenOperator(
{%- if side_outputs -%}
      std::vector<TypedSlot> named_output_slots
{%- endif -%}{#- side_outputs -#}
  )
      : QExprOperator(
          ::arolla::QExprOperatorSignature::Get(
              *kInputTypesInOrder,
              {{ lvalue_qtype(operator_data.output_id) }}))
{%- if side_outputs -%}
          ,
          named_output_slots_(std::move(named_output_slots))
{%- endif -%}{#- side_outputs -#}
  {}

  absl::StatusOr<std::unique_ptr<BoundOperator>> DoBind(
      absl::Span<const TypedSlot> input_slots,
      TypedSlot output_slot) const override {
    // allocate on heap to avoid stack overflow
    std::unique_ptr<Offsets> offsets(new Offsets);
{%- if operator_data.inputs %}
    for (size_t i = 0; i != {{ operator_data.inputs | length }}; ++i) {
      offsets->inputs[i] = input_slots[i].byte_offset();
    }
{%- endif -%}{#- operator_data.inputs #}
{%- if side_outputs %}
    for (size_t i = 0; i != {{ side_outputs | length }}; ++i) {
      offsets->named_outputs[i] = named_output_slots_[i].byte_offset();
    }
{%- endif -%}{#- side_outputs #}
    offsets->output = output_slot.byte_offset();
    return {std::unique_ptr<BoundOperator>(
        new GenBoundOperator(std::move(*offsets), output_slot))};
  }
{%- if side_outputs %}
   std::vector<TypedSlot> named_output_slots_;
{%- endif -%}{#- side_outputs #}
};

class GenCompiledExpr : public InplaceCompiledExpr {
 public:
  GenCompiledExpr()
      : InplaceCompiledExpr(
          absl::flat_hash_map<std::string, QTypePtr>(
              kNamedInputTypesInOrder->begin(),
              kNamedInputTypesInOrder->end()),
          {{ lvalue_qtype(operator_data.output_id) }},
{%- if side_outputs %}
          /*named_output_types=*/absl::flat_hash_map<std::string, QTypePtr>(
              kNamedOutputTypesInOrder->begin(),
              kNamedOutputTypesInOrder->end())
{%- else %}
          /*named_output_types=*/{}
{%- endif -%}{#- side_outputs -#}
  ) {}

  absl::StatusOr<std::unique_ptr<BoundExpr>> InplaceBind(
      const absl::flat_hash_map<std::string, TypedSlot>& input_slots,
      TypedSlot output_slot,
      const absl::flat_hash_map<std::string, TypedSlot>& named_output_slots)
      const final {
    static constexpr absl::string_view error_context = (
        "while binding operator generated by "
        "{{ build_target }}");
    ASSIGN_OR_RETURN(std::vector<TypedSlot> input_slots_in_order,
        FindSlotsAndVerifyTypes(*kNamedInputTypesInOrder, input_slots),
        _ << error_context);
    ASSIGN_OR_RETURN(std::vector<TypedSlot> named_output_slots_in_order,
        FindSlotsAndVerifyTypes(
{%- if side_outputs %}
            *kNamedOutputTypesInOrder,
{%- else -%}{#- side_outputs #}
            {},
{%- endif -%}{#- side_outputs #}
            named_output_slots),
        _ << error_context);

    ASSIGN_OR_RETURN(
        auto bound_op,
{%- if side_outputs %}
        GenOperator(
            std::move(named_output_slots_in_order)
        )
{%- else %}
        GenOperator()
{%- endif -%}{#- side_outputs -#}
        .DoBind(std::move(input_slots_in_order), output_slot));
    return std::make_unique<GenBoundExpr>(
        dynamic_cast<GenBoundOperator&>(*bound_op), input_slots, output_slot,
        named_output_slots);
  }
};

}  // namespace
}  // namespace impl{{ operator_id }}

{{ cpp_function_name.open_namespace_str }}

const InplaceCompiledExpr& {{ cpp_function_name.name }}() {
  static auto* expr = new ::impl{{ operator_id }}::GenCompiledExpr();
  return *expr;
}

{{ cpp_function_name.close_namespace_str }}
{% endfor %}{# cpp_function_name, operator_data #}
// NOLINTEND

